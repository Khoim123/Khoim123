--==============================================================================
-- Services & Libraries
--==============================================================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local Teams = game:GetService("Teams")
local Stats = game:GetService("Stats") -- FIXED: Added Stats service for Ping
local Camera = workspace.CurrentCamera
local Mouse = Players.LocalPlayer:GetMouse()
local GuiService = game:GetService("GuiService")

-- Load Fluent Library
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

--==============================================================================
-- Constants & Configuration
--==============================================================================
local CACHE_UPDATE_INTERVAL = 1
local MAX_TARGET_PARTS = {"Head", "UpperTorso", "HumanoidRootPart"}

--==============================================================================
-- Variables
--==============================================================================
local player = Players.LocalPlayer

-- FIXED: S·ª≠a Race Condition Character (Y√™u c·∫ßu s·ªë 5)
local function waitForCharacter()
    local char = player.Character
    if not char then char = player.CharacterAdded:Wait() end
    -- ƒê·ª£i cho ƒë·∫øn khi root part load xong
    local root = char:WaitForChild("HumanoidRootPart", 5)
    if not root then 
        return player.Character -- Fallback n·∫øu timeout
    end
    return char
end

local character = waitForCharacter()
local playerRoot, playerHumanoid

-- Hard Aimbot Settings
local HardSettings = {
    Enabled = false,
    Distance = 50,
    Smoothness = 0.5,
    CharacterTilt = false,
    TargetPart = "HumanoidRootPart",
    TeamCheck = false,
    FOVCheck = false,
    FOVSize = 200,
    ShowFOV = false,
    VisibilityCheck = false,
    PredictMovement = false,
    PredictionStrength = 0.1
}

-- Silent Aim Settings
local SilentSettings = {
    Enabled = false,
    FOVSize = 150,
    ShowFOV = false,
    TeamCheck = false,
    VisibilityCheck = false,
    PredictMovement = false,
    PredictionStrength = 0.1,
    HitChance = 100,
    TargetPart = "Head"
}

-- ESP Settings
local ESPSettings = {
    Enabled = false,
    ShowHighlight = true,
    ShowName = true,
    ShowHealth = true,
    HitboxSize = 1.5,
    TeamCheck = false
}

-- Shared Player Selection
local SelectedPlayerNames = {}
local SelectedPlayerUserIds = {}
local hardAimbotConnection
local playerCache = {}
local lastCacheUpdate = 0
local cachedViewportCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) -- FIXED: Cache variable

-- FOV Circles
local HardFOVCircle = Drawing.new("Circle")
HardFOVCircle.Thickness = 2
HardFOVCircle.NumSides = 64
HardFOVCircle.Radius = HardSettings.FOVSize
HardFOVCircle.Color = Color3.fromRGB(255, 255, 255)
HardFOVCircle.Visible = HardSettings.ShowFOV
HardFOVCircle.Filled = false
HardFOVCircle.Transparency = 0.8

local SilentFOVCircle = Drawing.new("Circle")
SilentFOVCircle.Thickness = 2
SilentFOVCircle.NumSides = 64
SilentFOVCircle.Radius = SilentSettings.FOVSize
SilentFOVCircle.Color = Color3.fromRGB(255, 0, 0)
SilentFOVCircle.Visible = SilentSettings.ShowFOV
SilentFOVCircle.Filled = false
SilentFOVCircle.Transparency = 0.8

-- ESP Objects
local ESPObjects = {}  -- Player -> {Highlight, BillboardGui, HitboxAdornments}

--==============================================================================
-- Optimization & Utility
--==============================================================================

-- FIXED: T·ªëi ∆∞u FOV Check - Cache Viewport (Y√™u c·∫ßu s·ªë 7)
RunService.RenderStepped:Connect(function()
    cachedViewportCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    -- Update FOV Circle Positions here strictly
    HardFOVCircle.Position = cachedViewportCenter
    SilentFOVCircle.Position = cachedViewportCenter
end)

local function updateHardFOVCircle()
    HardFOVCircle.Visible = HardSettings.ShowFOV
    HardFOVCircle.Radius = HardSettings.FOVSize
end

local function updateSilentFOVCircle()
    SilentFOVCircle.Visible = SilentSettings.ShowFOV
    SilentFOVCircle.Radius = SilentSettings.FOVSize
end

local function isInFOV(position, fovSize, center)
    local screenPos, onScreen = Camera:WorldToViewportPoint(position)
    if not onScreen then return false end
    local distance = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
    return distance <= fovSize
end

local function isVisible(targetPart)
    local check = HardSettings.VisibilityCheck or SilentSettings.VisibilityCheck
    if not check then return true end
    if not playerRoot then return false end
    
    local origin = playerRoot.Position
    local direction = (targetPart.Position - origin).Unit * (targetPart.Position - origin).Magnitude
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {character, targetPart.Parent}
    params.FilterType = Enum.RaycastFilterType.Exclude
    
    local result = workspace:Raycast(origin, direction, params)
    return result == nil -- Visible if nothing hit
end

local function shouldIgnoreTeam(targetPlayer, checkType)
    local teamCheck = checkType == "hard" and HardSettings.TeamCheck or 
                      checkType == "silent" and SilentSettings.TeamCheck or 
                      ESPSettings.TeamCheck
    if not teamCheck then return false end
    if not player.Team or not targetPlayer.Team then return false end
    return player.Team == targetPlayer.Team
end

-- FIXED: S·ª≠a Prediction th√™m Ping + Gravity (Y√™u c·∫ßu s·ªë 6)
local function calculatePrediction(targetPos, targetVelocity, strength)
    local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    local gravity = Vector3.new(0, workspace.Gravity * 0.5 * (ping ^ 2), 0) -- Simple gravity compensation
    return targetPos + (targetVelocity * strength * ping) + gravity -- Added Ping scaling
end

local function predictSilentPosition(targetPart)
    if not SilentSettings.PredictMovement then return targetPart.Position end
    local root = targetPart.Parent:FindFirstChild("HumanoidRootPart")
    if root then
        return calculatePrediction(targetPart.Position, root.AssemblyVelocity, SilentSettings.PredictionStrength)
    end
    return targetPart.Position
end

local function predictPosition(targetRoot, targetHumanoid, strength)
    if not HardSettings.PredictMovement then return targetRoot.Position end
    return calculatePrediction(targetRoot.Position, targetRoot.AssemblyVelocity, strength)
end

--==============================================================================
-- Silent Aim Logic (FIXED Hook)
--==============================================================================

local function getSilentTarget()
    if not SilentSettings.Enabled then return nil end
    -- Note: playerCache update is handled in main loops, calling here might be redundant but keeping for safety
    local closestTarget, shortestDist = nil, math.huge
    local center = cachedViewportCenter

    for userId, cachedPlayer in pairs(playerCache) do
        local targetPlayer = cachedPlayer.Player
        local hasSelected = next(SelectedPlayerUserIds) ~= nil
        if hasSelected and not SelectedPlayerUserIds[targetPlayer.UserId] then continue end
        
        if targetPlayer ~= player and not shouldIgnoreTeam(targetPlayer, "silent") then
            local targetPart = cachedPlayer.Character:FindFirstChild(SilentSettings.TargetPart) or 
                               cachedPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetPart and isVisible(targetPart) then
                local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    if dist <= SilentSettings.FOVSize and dist < shortestDist then
                        shortestDist = dist
                        closestTarget = targetPart
                    end
                end
            end
        end
    end
    return closestTarget
end

-- FIXED: S·ª≠a L·ªói Silent Aim Hook - D√πng hookmetamethod (Y√™u c·∫ßu s·ªë 4)
local oldIndex
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if SilentSettings.Enabled and self == Mouse and key == "Hit" then
        -- Random chance check handled here
        if math.random(1, 100) <= SilentSettings.HitChance then
            local targetPart = getSilentTarget()
            if targetPart then
                local predictedPos = predictSilentPosition(targetPart)
                return CFrame.new(Mouse.Hit.Position, predictedPos)
            end
        end
    end
    return oldIndex(self, key)
end))

--==============================================================================
-- Character Management
--==============================================================================

local function updatePlayerParts()
    if not character or not character.Parent then
        character = player.Character
        if not character then return false end
    end

    playerRoot = character:FindFirstChild("HumanoidRootPart")
    playerHumanoid = character:FindFirstChild("Humanoid")

    return playerRoot ~= nil and playerHumanoid ~= nil
end

player.CharacterAdded:Connect(function(newChar)
    character = waitForCharacter() -- Use safe wait
    task.wait(0.5)
    updatePlayerParts()
end)

--==============================================================================
-- Player Cache System
--==============================================================================

local function updatePlayerCache()
    local currentTime = tick()
    if currentTime - lastCacheUpdate < CACHE_UPDATE_INTERVAL then return end

    lastCacheUpdate = currentTime
    playerCache = {}

    for _, targetPlayer in ipairs(Players:GetPlayers()) do
        if targetPlayer ~= player and targetPlayer.Character then
            local targetChar = targetPlayer.Character
            local targetHumanoid = targetChar:FindFirstChildOfClass("Humanoid")
            local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")

            if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
                playerCache[targetPlayer.UserId] = {
                    Player = targetPlayer,
                    Character = targetChar,
                    Root = targetRoot,
                    Humanoid = targetHumanoid
                }
            end
        end
    end
end

--==============================================================================
-- Target Selection
--==============================================================================

local function isValidTarget(targetPlayer, checkType)
    if not targetPlayer or targetPlayer == player then return false end
    if shouldIgnoreTeam(targetPlayer, checkType) then return false end
    local hasSelectedPlayers = next(SelectedPlayerUserIds) ~= nil
    if hasSelectedPlayers then
        return SelectedPlayerUserIds[targetPlayer.UserId] == true
    end
    return true
end

local function getTargetPart(targetChar, partType)
    local partName = partType == "hard" and HardSettings.TargetPart or SilentSettings.TargetPart
    local part = targetChar:FindFirstChild(partName)
    if part then return part end
    for _, partName in ipairs(MAX_TARGET_PARTS) do
        part = targetChar:FindFirstChild(partName)
        if part then return part end
    end
    return nil
end

local function getNearestTarget()
    if not HardSettings.Enabled or not updatePlayerParts() then return nil end
    if playerHumanoid.Health <= 0 then return nil end

    updatePlayerCache()

    local closestTarget, shortestDist = nil, math.huge
    local playerPosition = playerRoot.Position
    local center = cachedViewportCenter

    for userId, cachedPlayer in pairs(playerCache) do
        if isValidTarget(cachedPlayer.Player, "hard") then
            local targetPart = getTargetPart(cachedPlayer.Character, "hard")
            if targetPart then
                local distance = (playerPosition - targetPart.Position).Magnitude
                if distance <= HardSettings.Distance and 
                   (not HardSettings.FOVCheck or isInFOV(targetPart.Position, HardSettings.FOVSize, center)) then
                    if isVisible(targetPart) and distance < shortestDist then
                        shortestDist = distance
                        closestTarget = {
                            Part = targetPart,
                            Root = cachedPlayer.Root,
                            Humanoid = cachedPlayer.Humanoid,
                            Distance = distance
                        }
                    end
                end
            end
        end
    end
    return closestTarget
end

--==============================================================================
-- Aiming Logic
--==============================================================================

local function aimAtTarget(targetData)
    if not updatePlayerParts() or playerHumanoid.Health <= 0 then return end

    local targetPos = predictPosition(targetData.Root, targetData.Humanoid, HardSettings.PredictionStrength)
    local aimPosition

    if HardSettings.CharacterTilt then
        if targetData.Part then 
             -- Re-calculate exact part pos with prediction if needed, keeping simple here
             aimPosition = targetPos 
        end
    else
        aimPosition = Vector3.new(targetPos.X, playerRoot.Position.Y, targetPos.Z)
    end

    local goalCFrame = CFrame.new(playerRoot.Position, aimPosition)
    local smoothFactor = math.clamp(HardSettings.Smoothness, 0.01, 1)
    local smoothedCFrame = playerRoot.CFrame:Lerp(goalCFrame, smoothFactor)

    playerRoot.CFrame = smoothedCFrame
end

local function aimbotLoop()
    local target = getNearestTarget()
    if target then aimAtTarget(target) end
end

local function toggleHardAimbot(state)
    HardSettings.Enabled = state
    if hardAimbotConnection then
        hardAimbotConnection:Disconnect()
        hardAimbotConnection = nil
    end
    if state then
        hardAimbotConnection = RunService.Heartbeat:Connect(aimbotLoop)
    end
end

local function toggleSilentAim(state)
    SilentSettings.Enabled = state
    Fluent:Notify({
        Title = "Silent Aim",
        Content = state and "ƒê√£ B·∫¨T" or "ƒê√£ T·∫ÆT",
        Duration = 2
    })
end

RunService.RenderStepped:Connect(function()
    updateHardFOVCircle()
    updateSilentFOVCircle()
end)

--==============================================================================
-- ESP Functions (FIXED: Memory Leak + BoxHandleAdornment)
--==============================================================================

local function createESP(targetPlayer)
    if ESPObjects[targetPlayer] then return end

    local char = targetPlayer.Character
    if not char then return end

    -- White Highlight
    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromRGB(255, 255, 255)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Parent = char
    highlight.Adornee = char

    -- BillboardGui
    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.Parent = char:FindFirstChild("Head") or char.PrimaryPart
    billboard.Adornee = char:FindFirstChild("Head") or char.PrimaryPart
    billboard.AlwaysOnTop = true

    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = targetPlayer.Name
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextSize = 16
    nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.Parent = billboard

    local healthLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    healthLabel.Position = UDim2.new(0, 0, 0.5, 0)
    healthLabel.BackgroundTransparency = 1
    healthLabel.Text = "Health"
    healthLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
    healthLabel.TextSize = 14
    healthLabel.Font = Enum.Font.SourceSans
    healthLabel.Parent = billboard

    -- FIXED: S·ª≠a l·ªói ESP Hitbox - D√πng BoxHandleAdornment (Y√™u c·∫ßu s·ªë 2)
    local hitboxes = {}
    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") then
            local adornment = Instance.new("BoxHandleAdornment")
            adornment.Name = "ESPHitbox"
            adornment.Adornee = part
            adornment.AlwaysOnTop = true
            adornment.ZIndex = 1
            adornment.Transparency = 0.6
            adornment.Color3 = Color3.fromRGB(255, 0, 0)
            adornment.Parent = part
            adornment.Size = part.Size -- Initial size
            table.insert(hitboxes, {Part = part, Adornment = adornment})
        end
    end

    ESPObjects[targetPlayer] = {
        Highlight = highlight, 
        Billboard = billboard, 
        NameLabel = nameLabel, 
        HealthLabel = healthLabel,
        Hitboxes = hitboxes -- Store adornments here
    }
end

local function updateHitboxScale(targetPlayer, scale)
    local data = ESPObjects[targetPlayer]
    if not data or not data.Hitboxes then return end
    
    for _, hbData in ipairs(data.Hitboxes) do
        if hbData.Part and hbData.Part.Parent and hbData.Adornment then
            -- Scale visual only, do not change Part.Size
            hbData.Adornment.Size = hbData.Part.Size * scale
            hbData.Adornment.Visible = true
        end
    end
end

local function updateESP()
    if not ESPSettings.Enabled then
        for player, data in pairs(ESPObjects) do
            if data.Highlight then data.Highlight.Enabled = false end
            if data.Billboard then data.Billboard.Enabled = false end
            -- Hide hitboxes
            if data.Hitboxes then
                for _, hb in ipairs(data.Hitboxes) do
                    if hb.Adornment then hb.Adornment.Visible = false end
                end
            end
        end
        return
    end

    updatePlayerCache()

    for userId, cached in pairs(playerCache) do
        local targetPlayer = cached.Player
        local hasSelected = next(SelectedPlayerUserIds) ~= nil
        if hasSelected and not SelectedPlayerUserIds[targetPlayer.UserId] then continue end

        if targetPlayer ~= player and not shouldIgnoreTeam(targetPlayer, "esp") then
            createESP(targetPlayer)
            local data = ESPObjects[targetPlayer]
            local char = cached.Character
            local humanoid = cached.Humanoid

            if char and humanoid and data then
                -- Highlight
                if ESPSettings.ShowHighlight then
                    data.Highlight.Adornee = char
                    data.Highlight.Enabled = true
                else
                    data.Highlight.Enabled = false
                end

                -- Name/Health
                if ESPSettings.ShowName then
                    data.NameLabel.Text = targetPlayer.Name
                    data.NameLabel.Visible = true
                else
                    data.NameLabel.Visible = false
                end

                if ESPSettings.ShowHealth then
                    local health = humanoid.Health
                    local maxHealth = humanoid.MaxHealth
                    data.HealthLabel.Text = string.format("Health: %d/%d", math.floor(health), maxHealth)
                    data.HealthLabel.TextColor3 = health > maxHealth * 0.5 and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
                    data.HealthLabel.Visible = true
                else
                    data.HealthLabel.Visible = false
                end
                
                data.Billboard.Enabled = ESPSettings.ShowName or ESPSettings.ShowHealth

                -- Hitbox Visual Update
                updateHitboxScale(targetPlayer, ESPSettings.HitboxSize)
            end
        end
    end
end

RunService.Heartbeat:Connect(updateESP)

local function destroyESPObj(player)
    if ESPObjects[player] then
        if ESPObjects[player].Highlight then ESPObjects[player].Highlight:Destroy() end
        if ESPObjects[player].Billboard then ESPObjects[player].Billboard:Destroy() end
        if ESPObjects[player].Hitboxes then
            for _, hb in ipairs(ESPObjects[player].Hitboxes) do
                if hb.Adornment then hb.Adornment:Destroy() end
            end
        end
        ESPObjects[player] = nil
    end
end

local function toggleESP(state)
    ESPSettings.Enabled = state
    if not state then
        for p, _ in pairs(ESPObjects) do
            destroyESPObj(p)
        end
        ESPObjects = {}
    end
    Fluent:Notify({
        Title = "ESP",
        Content = state and "ƒê√£ B·∫¨T" or "ƒê√£ T·∫ÆT",
        Duration = 2
    })
end

-- FIXED: S·ª≠a L·ªói Memory Leak khi Respawn (Y√™u c·∫ßu s·ªë 3)
Players.PlayerAdded:Connect(function(newPlayer)
    newPlayer.CharacterAdded:Connect(function()
        -- Cleanup old objects explicitly
        destroyESPObj(newPlayer)
        task.wait(1)
        if ESPSettings.Enabled then
            createESP(newPlayer)
        end
    end)
end)

Players.PlayerRemoving:Connect(function(p)
    destroyESPObj(p)
    SelectedPlayerNames[p.Name] = nil
    SelectedPlayerUserIds[p.UserId] = nil
    -- Callback refresh handled in UI section
end)

--==============================================================================
-- UI Creation
--==============================================================================

local Window = Fluent:CreateWindow({
    Title = "Aimbot Pro + Silent + ESP - Fixed",
    SubTitle = "Enhanced 2025",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 520),
    Acrylic = true,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ Title = "Aimbot", Icon = "crosshair" }),
    Advanced = Window:AddTab({ Title = "N√¢ng cao", Icon = "settings" }),
    Silent = Window:AddTab({ Title = "Silent Aim", Icon = "target" }),
    Players = Window:AddTab({ Title = "M·ª•c ti√™u", Icon = "users" }),
    Visual = Window:AddTab({ Title = "Hi·ªÉn th·ªã", Icon = "eye" }),
    ESP = Window:AddTab({ Title = "ESP", Icon = "map" })
}

-- Main Tab
local MainSection = Tabs.Main:AddSection("ƒêi·ªÅu khi·ªÉn ch√≠nh")

Tabs.Main:AddToggle("HardAimbotEnabled", {
    Title = "B·∫≠t Hard Aimbot",
    Default = false,
    Callback = function(value)
        toggleHardAimbot(value)
        Fluent:Notify({Title = "Hard Aimbot", Content = value and "ƒê√£ B·∫¨T" or "ƒê√£ T·∫ÆT", Duration = 2})
    end
})

Tabs.Main:AddToggle("SilentAimbotEnabled", {
    Title = "B·∫≠t Silent Aim",
    Default = false,
    Callback = function(value) toggleSilentAim(value) end
})

Tabs.Main:AddSlider("HardDistance", {
    Title = "Kho·∫£ng c√°ch (Hard)", Default = 50, Min = 10, Max = 1000, Rounding = 0,
    Callback = function(value) HardSettings.Distance = value end
})

Tabs.Main:AddSlider("HardSmoothness", {
    Title = "ƒê·ªô m∆∞·ª£t (Hard)", Default = 0.5, Min = 0.01, Max = 1, Rounding = 2,
    Callback = function(value) HardSettings.Smoothness = value end
})

Tabs.Main:AddDropdown("HardTargetPart", {
    Title = "Ph·∫ßn c∆° th·ªÉ ng·∫Øm (Hard)", Values = {"Head", "UpperTorso", "HumanoidRootPart"}, Default = "HumanoidRootPart",
    Callback = function(value) HardSettings.TargetPart = value end
})

-- Advanced Tab
local AdvancedSection = Tabs.Advanced:AddSection("T√πy ch·ªçn n√¢ng cao (Hard)")

Tabs.Advanced:AddToggle("CharacterTilt", {
    Title = "Ng·∫Øm theo chi·ªÅu d·ªçc", Default = false,
    Callback = function(value) HardSettings.CharacterTilt = value end
})

Tabs.Advanced:AddToggle("HardTeamCheck", {
    Title = "B·ªè qua ƒë·ªìng ƒë·ªôi (Hard)", Default = false,
    Callback = function(value) HardSettings.TeamCheck = value end
})

Tabs.Advanced:AddToggle("HardVisibilityCheck", {
    Title = "Ki·ªÉm tra t·∫ßm nh√¨n (Hard)", Default = false,
    Callback = function(value) HardSettings.VisibilityCheck = value end
})

Tabs.Advanced:AddToggle("HardPredictMovement", {
    Title = "D·ª± ƒëo√°n di chuy·ªÉn (Hard)", Default = false,
    Callback = function(value) HardSettings.PredictMovement = value end
})

Tabs.Advanced:AddSlider("HardPredictionStrength", {
    Title = "ƒê·ªô m·∫°nh d·ª± ƒëo√°n (Hard)", Default = 0.1, Min = 0, Max = 1, Rounding = 2,
    Callback = function(value) HardSettings.PredictionStrength = value end
})

-- Silent Tab
local SilentSection = Tabs.Silent:AddSection("C√†i ƒë·∫∑t Silent")

Tabs.Silent:AddSlider("SilentFOVSize", {
    Title = "K√≠ch th∆∞·ªõc FOV (Silent)", Default = 150, Min = 50, Max = 500, Rounding = 0,
    Callback = function(value) SilentSettings.FOVSize = value end
})

Tabs.Silent:AddToggle("SilentTeamCheck", {
    Title = "B·ªè qua ƒë·ªìng ƒë·ªôi (Silent)", Default = false,
    Callback = function(value) SilentSettings.TeamCheck = value end
})

Tabs.Silent:AddToggle("SilentVisibilityCheck", {
    Title = "Ki·ªÉm tra t·∫ßm nh√¨n (Silent)", Default = false,
    Callback = function(value) SilentSettings.VisibilityCheck = value end
})

Tabs.Silent:AddToggle("SilentPredictMovement", {
    Title = "D·ª± ƒëo√°n di chuy·ªÉn (Silent)", Default = false,
    Callback = function(value) SilentSettings.PredictMovement = value end
})

Tabs.Silent:AddSlider("SilentPredictionStrength", {
    Title = "ƒê·ªô m·∫°nh d·ª± ƒëo√°n (Silent)", Default = 0.1, Min = 0, Max = 1, Rounding = 2,
    Callback = function(value) SilentSettings.PredictionStrength = value end
})

Tabs.Silent:AddSlider("SilentHitChance", {
    Title = "T·ª∑ l·ªá hit (%)", Default = 100, Min = 0, Max = 100, Rounding = 0,
    Callback = function(value) SilentSettings.HitChance = value end
})

Tabs.Silent:AddDropdown("SilentTargetPart", {
    Title = "Ph·∫ßn c∆° th·ªÉ ng·∫Øm (Silent)", Values = {"Head", "HumanoidRootPart", "UpperTorso"}, Default = "Head",
    Callback = function(value) SilentSettings.TargetPart = value end
})

-- Players Tab
local PlayersSection = Tabs.Players:AddSection("Qu·∫£n l√Ω m·ª•c ti√™u")

local PlayerList = Tabs.Players:AddParagraph({
    Title = "Tr·∫°ng th√°i",
    Content = "ƒêang t·∫£i..."
})

local function updatePlayerListStatus()
    local playerCount = #Players:GetPlayers() - 1
    local selectedCount = 0
    for _ in pairs(SelectedPlayerUserIds) do selectedCount = selectedCount + 1 end

    local statusText = selectedCount == 0 and "üéØ Ch·∫ø ƒë·ªô: Ng·∫Øm T·∫§T C·∫¢" or 
                       string.format("üéØ Ch·∫ø ƒë·ªô: Ch·ªâ ng·∫Øm %d ng∆∞·ªùi ƒë√£ ch·ªçn", selectedCount)

    local newContent = string.format("üë• Ng∆∞·ªùi ch∆°i kh√°c: %d\n%s", playerCount, statusText)
    
    -- FIXED: S·ª≠a l·ªói Fluent Library (Y√™u c·∫ßu s·ªë 1) - D√πng SetDesc thay v√¨ SetContent
    PlayerList:SetDesc(newContent)
    
    task.wait(0.1)
    PlayerList:SetDesc(newContent)
end

local PlayerDropdown = Tabs.Players:AddDropdown("PlayerSelector", {
    Title = "Ch·ªçn m·ª•c ti√™u c·ª• th·ªÉ",
    Description = "ƒê·ªÉ tr·ªëng = ng·∫Øm t·∫•t c·∫£",
    Values = {},
    Multi = true,
    Default = {},
    Callback = function(values)
        SelectedPlayerNames = {}
        SelectedPlayerUserIds = {}
        for _, playerName in ipairs(values) do
            local targetPlayer = Players:FindFirstChild(playerName)
            if targetPlayer then
                SelectedPlayerNames[playerName] = true
                SelectedPlayerUserIds[targetPlayer.UserId] = true
                Fluent:Notify({Title = "ƒê√£ ch·ªçn", Content = "Th√™m " .. playerName, Duration = 1})
            end
        end
        updatePlayerListStatus()
        local selectedCount = #values
        local targetInfo = selectedCount == 0 and "t·∫•t c·∫£" or selectedCount .. " ng∆∞·ªùi"
        Fluent:Notify({Title = "C·∫≠p nh·∫≠t m·ª•c ti√™u", Content = "ƒêang ng·∫Øm: " .. targetInfo, Duration = 2})
    end
})

local function refreshPlayerDropdown()
    local playerNames = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player then table.insert(playerNames, p.Name) end
    end
    table.sort(playerNames)
    PlayerDropdown:SetValues(playerNames)
    updatePlayerListStatus()
end

Tabs.Players:AddButton({
    Title = "üîÑ L√†m m·ªõi danh s√°ch",
    Description = "C·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi ch∆°i m·ªõi",
    Callback = function()
        refreshPlayerDropdown()
        Fluent:Notify({ Title = "L√†m m·ªõi", Content = "ƒê√£ c·∫≠p nh·∫≠t danh s√°ch", Duration = 2 })
    end
})

Tabs.Players:AddButton({
    Title = "‚ùå B·ªè ch·ªçn t·∫•t c·∫£",
    Description = "X√≥a t·∫•t c·∫£ m·ª•c ti√™u ‚Üí Ng·∫Øm t·∫•t c·∫£ ng∆∞·ªùi ch∆°i",
    Callback = function()
        SelectedPlayerNames = {}
        SelectedPlayerUserIds = {}
        PlayerDropdown:SetValue({})
        updatePlayerListStatus()
        Fluent:Notify({ Title = "ƒê√£ x√≥a", Content = "Chuy·ªÉn sang ch·∫ø ƒë·ªô ng·∫Øm T·∫§T C·∫¢", Duration = 2 })
    end
})

-- FIXED: S·ª≠a l·ªói ƒë·ªìng b·ªô Dropdown khi player leave (Y√™u c·∫ßu s·ªë 8)
Players.PlayerRemoving:Connect(function(p)
    refreshPlayerDropdown()
end)

Players.PlayerAdded:Connect(function(newPlayer)
    task.wait(1)
    refreshPlayerDropdown()
end)

-- Visual Tab
local VisualSection = Tabs.Visual:AddSection("FOV Circles")

Tabs.Visual:AddToggle("HardShowFOV", {
    Title = "Hi·ªÉn th·ªã FOV (Hard)", Default = false,
    Callback = function(value) HardSettings.ShowFOV = value end
})

Tabs.Visual:AddToggle("HardFOVCheck", {
    Title = "Ki·ªÉm tra FOV (Hard)", Default = false,
    Callback = function(value) HardSettings.FOVCheck = value end
})

Tabs.Visual:AddSlider("HardFOVSize", {
    Title = "K√≠ch th∆∞·ªõc FOV (Hard)", Default = 200, Min = 50, Max = 500, Rounding = 0,
    Callback = function(value) HardSettings.FOVSize = value end
})

Tabs.Visual:AddToggle("SilentShowFOV", {
    Title = "Hi·ªÉn th·ªã FOV (Silent)", Default = false,
    Callback = function(value) SilentSettings.ShowFOV = value end
})

-- ESP Tab
local ESPSection = Tabs.ESP:AddSection("ESP Settings")

Tabs.ESP:AddToggle("ESPToggle", {
    Title = "B·∫≠t ESP", Default = false,
    Callback = function(value) toggleESP(value) end
})

Tabs.ESP:AddToggle("ESPShowHighlight", {
    Title = "Hi·ªÉn th·ªã Highlight Tr·∫Øng", Default = true,
    Callback = function(value) ESPSettings.ShowHighlight = value end
})

Tabs.ESP:AddToggle("ESPShowName", {
    Title = "Hi·ªÉn th·ªã T√™n", Default = true,
    Callback = function(value) ESPSettings.ShowName = value end
})

Tabs.ESP:AddToggle("ESPShowHealth", {
    Title = "Hi·ªÉn th·ªã M√°u", Default = true,
    Callback = function(value) ESPSettings.ShowHealth = value end
})

Tabs.ESP:AddSlider("ESPHitboxSize", {
    Title = "K√≠ch th∆∞·ªõc Visual Hitbox", Default = 1.5, Min = 1, Max = 5, Rounding = 1,
    Callback = function(value) ESPSettings.HitboxSize = value end
})

Tabs.ESP:AddToggle("ESPTeamCheck", {
    Title = "B·ªè qua ƒë·ªìng ƒë·ªôi", Default = false,
    Callback = function(value) ESPSettings.TeamCheck = value end
})

--==============================================================================
-- Floating Toggle Button
--==============================================================================
local ToggleButton = Instance.new("ScreenGui")
ToggleButton.Name = "FixedToggle"
ToggleButton.ResetOnSpawn = false
ToggleButton.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ToggleButton.IgnoreGuiInset = true
ToggleButton.Parent = gethui and gethui() or CoreGui

local ToggleFrame = Instance.new("Frame")
ToggleFrame.Size = UDim2.new(0, 50, 0, 50)
ToggleFrame.Position = UDim2.new(0, 20, 0.5, -25)
ToggleFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
ToggleFrame.BorderSizePixel = 0
ToggleFrame.Active = true
ToggleFrame.Parent = ToggleButton

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = ToggleFrame

local UIStroke = Instance.new("UIStroke")
UIStroke.Color = Color3.fromRGB(80, 80, 80)
UIStroke.Thickness = 1.5
UIStroke.Parent = ToggleFrame

local ToggleBtn = Instance.new("TextButton")
ToggleBtn.Size = UDim2.new(1, 0, 1, 0)
ToggleBtn.BackgroundTransparency = 1
ToggleBtn.Text = "üéØ"
ToggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleBtn.TextSize = 24
ToggleBtn.Font = Enum.Font.GothamBold
ToggleBtn.Parent = ToggleFrame

local dragging, dragStart, startPos = false, nil, nil
ToggleFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = ToggleFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragging = false end
        end)
    end
end)

ToggleFrame.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        local newPos = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        local screenSize = Camera.ViewportSize
        newPos = UDim2.new(
            math.clamp(newPos.X.Scale, 0, 1), math.clamp(newPos.X.Offset, 0, screenSize.X - 50),
            math.clamp(newPos.Y.Scale, 0, 1), math.clamp(newPos.Y.Offset, 0, screenSize.Y - 50)
        )
        TweenService:Create(ToggleFrame, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {Position = newPos}):Play()
    end
end)

local guiMinimized = false
ToggleBtn.MouseButton1Click:Connect(function()
    guiMinimized = not guiMinimized
    Window:Minimize()
    local targetSize = guiMinimized and UDim2.new(0, 40, 0, 40) or UDim2.new(0, 50, 0, 50)
    local targetColor = guiMinimized and Color3.fromRGB(60, 60, 60) or Color3.fromRGB(30, 30, 30)
    local targetTextSize = guiMinimized and 20 or 24
    TweenService:Create(ToggleFrame, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {Size = targetSize, BackgroundColor3 = targetColor}):Play()
    TweenService:Create(UIStroke, TweenInfo.new(0.2), {Color = guiMinimized and Color3.fromRGB(150, 150, 150) or Color3.fromRGB(80, 80, 80)}):Play()
    TweenService:Create(ToggleBtn, TweenInfo.new(0.2), {TextSize = targetTextSize}):Play()
end)

RunService.Heartbeat:Connect(function()
    local isAnyOn = HardSettings.Enabled or SilentSettings.Enabled or ESPSettings.Enabled
    local targetColor = isAnyOn and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    UIStroke.Color = UIStroke.Color:Lerp(targetColor, 0.1)
end)

--==============================================================================
-- Initialization
--==============================================================================
updatePlayerParts()
refreshPlayerDropdown()

Fluent:Notify({Title = "Script Loaded", Content = "LethanhKhoi hub (Fixed Version)", Duration = 5})
