--==============================================================================
-- [FIXED VERSION] Aimbot Pro + Silent + ESP
-- Fixed Issues: #1-12 (All Critical, High, Medium Priority)
-- FINAL FIXES: Player Selection System Synchronization
--==============================================================================

-- Services & Libraries
--==============================================================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local Teams = game:GetService("Teams")
local Stats = game:GetService("Stats")
local Camera = workspace.CurrentCamera
local Mouse = Players.LocalPlayer:GetMouse()
local GuiService = game:GetService("GuiService")

-- Load Fluent Library
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

--==============================================================================
-- Error Handling & Debug
--==============================================================================
-- FIXED: Global error handler & Debug Mode
local DEBUG_MODE = false

local function debugPrint(...)
    if DEBUG_MODE then
        print("[Aimbot Debug]", ...)
    end
end

local function safeCall(func, context)
    local success, err = pcall(func)
    if not success then
        warn("[Aimbot Error - " .. context .. "]:", err)
    end
    return success
end

--==============================================================================
-- Constants & Configuration
--==============================================================================
local CACHE_UPDATE_INTERVAL = 1
local MAX_TARGET_PARTS = {"Head", "UpperTorso", "HumanoidRootPart"}

--==============================================================================
-- Variables
--==============================================================================
local player = Players.LocalPlayer

-- FIXED #6: Character Loading - Timeout & Retry
local function waitForCharacter()
    local char = player.Character
    if not char then char = player.CharacterAdded:Wait() end
    
    -- ƒê·ª£i c·∫£ 2 parts quan tr·ªçng ƒë·ªÉ tr√°nh crash logic aimbot
    local root = char:WaitForChild("HumanoidRootPart", 10)
    local humanoid = char:WaitForChild("Humanoid", 10)
    
    -- Retry n·∫øu timeout
    if not root or not humanoid then
        warn("[Aimbot] Character parts timeout, retrying...")
        task.wait(0.5)
        return waitForCharacter() -- Recursive retry
    end
    
    return char
end

local character = waitForCharacter()
local playerRoot, playerHumanoid

-- Hard Aimbot Settings
local HardSettings = {
    Enabled = false,
    Distance = 50,
    Smoothness = 0.5,
    CharacterTilt = false,
    TargetPart = "HumanoidRootPart",
    TeamCheck = false,
    FOVCheck = false,
    FOVSize = 200,
    ShowFOV = false,
    VisibilityCheck = false,
    PredictMovement = false,
    PredictionStrength = 0.1
}

-- Silent Aim Settings
local SilentSettings = {
    Enabled = false,
    FOVSize = 150,
    ShowFOV = false,
    TeamCheck = false,
    VisibilityCheck = false,
    PredictMovement = false,
    PredictionStrength = 0.1,
    HitChance = 100,
    TargetPart = "Head"
}

-- ESP Settings
local ESPSettings = {
    Enabled = false,
    ShowHighlight = true,
    ShowName = true,
    ShowHealth = true,
    HitboxSize = 1.5,
    TeamCheck = false
}

-- Shared Player Selection
local SelectedPlayerNames = {}
local SelectedPlayerUserIds = {}
local hardAimbotConnection
local playerCache = {}
local lastCacheUpdate = 0
local cachedViewportCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

-- FOV Circles
local HardFOVCircle = Drawing.new("Circle")
HardFOVCircle.Thickness = 2
HardFOVCircle.NumSides = 64
HardFOVCircle.Radius = HardSettings.FOVSize
HardFOVCircle.Color = Color3.fromRGB(255, 255, 255)
HardFOVCircle.Visible = HardSettings.ShowFOV
HardFOVCircle.Filled = false
HardFOVCircle.Transparency = 0.8

local SilentFOVCircle = Drawing.new("Circle")
SilentFOVCircle.Thickness = 2
SilentFOVCircle.NumSides = 64
SilentFOVCircle.Radius = SilentSettings.FOVSize
SilentFOVCircle.Color = Color3.fromRGB(255, 0, 0)
SilentFOVCircle.Visible = SilentSettings.ShowFOV
SilentFOVCircle.Filled = false
SilentFOVCircle.Transparency = 0.8

-- ESP Objects
local ESPObjects = {}  -- Player -> {Highlight, BillboardGui, HitboxAdornments}

--==============================================================================
-- Optimization & Utility
--==============================================================================

-- FIXED #7 (Optimization): Cache Viewport
RunService.RenderStepped:Connect(function()
    cachedViewportCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    HardFOVCircle.Position = cachedViewportCenter
    SilentFOVCircle.Position = cachedViewportCenter
end)

local function updateHardFOVCircle()
    HardFOVCircle.Visible = HardSettings.ShowFOV
    HardFOVCircle.Radius = HardSettings.FOVSize
end

local function updateSilentFOVCircle()
    SilentFOVCircle.Visible = SilentSettings.ShowFOV
    SilentFOVCircle.Radius = SilentSettings.FOVSize
end

local function isInFOV(position, fovSize, center)
    local screenPos, onScreen = Camera:WorldToViewportPoint(position)
    if not onScreen then return false end
    local distance = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
    return distance <= fovSize
end

-- FIXED #4: Raycast - Check distance
local function isVisible(targetPart)
    local check = HardSettings.VisibilityCheck or SilentSettings.VisibilityCheck
    if not check then return true end
    if not playerRoot then return false end
    
    local origin = playerRoot.Position
    local targetPos = targetPart.Position
    local direction = (targetPos - origin)
    local distance = direction.Magnitude
    
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {character, targetPart.Parent}
    params.FilterType = Enum.RaycastFilterType.Exclude
    
    -- Raycast ƒë√∫ng ƒë·ªô d√†i kho·∫£ng c√°ch t·ªõi m·ª•c ti√™u
    local result = workspace:Raycast(origin, direction.Unit * distance, params)
    
    -- Visible n·∫øu: kh√¥ng hit G√å HO·∫∂C hit part xa h∆°n/b·∫±ng target (tolerance -1 stud)
    if not result then return true end
    return (result.Position - origin).Magnitude >= (distance - 1)
end

local function shouldIgnoreTeam(targetPlayer, checkType)
    local teamCheck = checkType == "hard" and HardSettings.TeamCheck or 
                      checkType == "silent" and SilentSettings.TeamCheck or 
                      ESPSettings.TeamCheck
    if not teamCheck then return false end
    if not player.Team or not targetPlayer.Team then return false end
    return player.Team == targetPlayer.Team
end

-- FIXED #3: Physics - Gravity Prediction Formula
local function calculatePrediction(targetPos, targetVelocity, strength)
    local pingSeconds = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    -- Roblox Gravity = 196.2 studs/s¬≤, r∆°i xu·ªëng n√™n √ÇM, c√¥ng th·ª©c 0.5 * g * t^2
    local dropDistance = workspace.Gravity * (pingSeconds ^ 2) * 0.5
    local gravity = Vector3.new(0, -dropDistance, 0) -- D·∫•u √ÇM ch√≠nh x√°c
    return targetPos + (targetVelocity * strength * pingSeconds) + gravity
end

local function predictSilentPosition(targetPart)
    if not SilentSettings.PredictMovement then return targetPart.Position end
    local root = targetPart.Parent:FindFirstChild("HumanoidRootPart")
    if root then
        return calculatePrediction(targetPart.Position, root.AssemblyVelocity, SilentSettings.PredictionStrength)
    end
    return targetPart.Position
end

local function predictPosition(targetRoot, targetHumanoid, strength)
    if not HardSettings.PredictMovement then return targetRoot.Position end
    return calculatePrediction(targetRoot.Position, targetRoot.AssemblyVelocity, strength)
end

--==============================================================================
-- Silent Aim Logic (FIXED Hook)
--==============================================================================

local function getSilentTarget()
    if not SilentSettings.Enabled then return nil end
    
    -- FIXED #12: Validation GetSilentTarget Nil Safety
    if not updatePlayerParts() or not playerRoot then return nil end
    updatePlayerCache()
    if not next(playerCache) then return nil end

    local closestTarget, shortestDist = nil, math.huge
    local center = cachedViewportCenter

    for userId, cachedPlayer in pairs(playerCache) do
        local targetPlayer = cachedPlayer.Player
        local hasSelected = next(SelectedPlayerUserIds) ~= nil
        if hasSelected and not SelectedPlayerUserIds[targetPlayer.UserId] then continue end
        
        if targetPlayer ~= player and not shouldIgnoreTeam(targetPlayer, "silent") then
            local targetPart = cachedPlayer.Character:FindFirstChild(SilentSettings.TargetPart) or 
                               cachedPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetPart and isVisible(targetPart) then
                local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    if dist <= SilentSettings.FOVSize and dist < shortestDist then
                        shortestDist = dist
                        closestTarget = targetPart
                    end
                end
            end
        end
    end
    return closestTarget
end

-- FIXED #5: Silent Hook Thi·∫øu Validation & Typeof check
local oldIndex
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if SilentSettings.Enabled and self == Mouse and key == "Hit" then
        if math.random(1, 100) <= SilentSettings.HitChance then
            local targetPart = getSilentTarget()
            if targetPart then
                local predictedPos = predictSilentPosition(targetPart)
                -- Check predictedPos tr∆∞·ªõc khi d√πng
                if predictedPos and typeof(predictedPos) == "Vector3" then
                    return CFrame.new(Mouse.Hit.Position, predictedPos)
                end
            end
        end
    end
    return oldIndex(self, key)
end))

--==============================================================================
-- Character Management
--==============================================================================

local function updatePlayerParts()
    if not character or not character.Parent then
        character = player.Character
        if not character then return false end
    end

    playerRoot = character:FindFirstChild("HumanoidRootPart")
    playerHumanoid = character:FindFirstChild("Humanoid")

    return playerRoot ~= nil and playerHumanoid ~= nil
end

player.CharacterAdded:Connect(function(newChar)
    character = waitForCharacter()
    task.wait(0.5)
    updatePlayerParts()
end)

--==============================================================================
-- Player Cache System
--==============================================================================

local function updatePlayerCache()
    local currentTime = tick()
    if currentTime - lastCacheUpdate < CACHE_UPDATE_INTERVAL then return end

    lastCacheUpdate = currentTime
    playerCache = {}

    for _, targetPlayer in ipairs(Players:GetPlayers()) do
        if targetPlayer ~= player and targetPlayer.Character then
            local targetChar = targetPlayer.Character
            local targetHumanoid = targetChar:FindFirstChildOfClass("Humanoid")
            local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")

            if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
                playerCache[targetPlayer.UserId] = {
                    Player = targetPlayer,
                    Character = targetChar,
                    Root = targetRoot,
                    Humanoid = targetHumanoid
                }
            end
        end
    end
end

--==============================================================================
-- Target Selection
--==============================================================================

local function isValidTarget(targetPlayer, checkType)
    if not targetPlayer or targetPlayer == player then return false end
    if shouldIgnoreTeam(targetPlayer, checkType) then return false end
    local hasSelectedPlayers = next(SelectedPlayerUserIds) ~= nil
    if hasSelectedPlayers then
        return SelectedPlayerUserIds[targetPlayer.UserId] == true
    end
    return true
end

local function getTargetPart(targetChar, partType)
    local partName = partType == "hard" and HardSettings.TargetPart or SilentSettings.TargetPart
    local part = targetChar:FindFirstChild(partName)
    if part then return part end
    for _, partName in ipairs(MAX_TARGET_PARTS) do
        part = targetChar:FindFirstChild(partName)
        if part then return part end
    end
    return nil
end

local function getNearestTarget()
    if not HardSettings.Enabled or not updatePlayerParts() then return nil end
    if playerHumanoid.Health <= 0 then return nil end

    updatePlayerCache()

    local closestTarget, shortestDist = nil, math.huge
    local playerPosition = playerRoot.Position
    local center = cachedViewportCenter

    for userId, cachedPlayer in pairs(playerCache) do
        if isValidTarget(cachedPlayer.Player, "hard") then
            local targetPart = getTargetPart(cachedPlayer.Character, "hard")
            if targetPart then
                local distance = (playerPosition - targetPart.Position).Magnitude
                if distance <= HardSettings.Distance and 
                   (not HardSettings.FOVCheck or isInFOV(targetPart.Position, HardSettings.FOVSize, center)) then
                    if isVisible(targetPart) and distance < shortestDist then
                        shortestDist = distance
                        closestTarget = {
                            Part = targetPart,
                            Root = cachedPlayer.Root,
                            Humanoid = cachedPlayer.Humanoid,
                            Distance = distance
                        }
                    end
                end
            end
        end
    end
    return closestTarget
end

--==============================================================================
-- Aiming Logic
--==============================================================================

local function aimAtTarget(targetData)
    if not updatePlayerParts() or playerHumanoid.Health <= 0 then return end

    local targetPos = predictPosition(targetData.Root, targetData.Humanoid, HardSettings.PredictionStrength)
    local aimPosition

    if HardSettings.CharacterTilt then
        if targetData.Part then 
             aimPosition = targetPos 
        end
    else
        aimPosition = Vector3.new(targetPos.X, playerRoot.Position.Y, targetPos.Z)
    end

    local goalCFrame = CFrame.new(playerRoot.Position, aimPosition)
    local smoothFactor = math.clamp(HardSettings.Smoothness, 0.01, 1)
    local smoothedCFrame = playerRoot.CFrame:Lerp(goalCFrame, smoothFactor)

    playerRoot.CFrame = smoothedCFrame
end

local function aimbotLoop()
    local target = getNearestTarget()
    if target then aimAtTarget(target) end
end

local function toggleHardAimbot(state)
    HardSettings.Enabled = state
    if hardAimbotConnection then
        hardAimbotConnection:Disconnect()
        hardAimbotConnection = nil
    end
    if state then
        hardAimbotConnection = RunService.Heartbeat:Connect(aimbotLoop)
    end
end

local function toggleSilentAim(state)
    SilentSettings.Enabled = state
    Fluent:Notify({
        Title = "Silent Aim",
        Content = state and "ƒê√£ B·∫¨T" or "ƒê√£ T·∫ÆT",
        Duration = 2
    })
end

RunService.RenderStepped:Connect(function()
    updateHardFOVCircle()
    updateSilentFOVCircle()
end)

--==============================================================================
-- ESP Functions (FIXED: All Issues)
--==============================================================================

local function createESP(targetPlayer)
    if ESPObjects[targetPlayer] then return end

    local char = targetPlayer.Character
    if not char then return end

    -- White Highlight
    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromRGB(255, 255, 255)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Parent = char
    highlight.Adornee = char

    -- BillboardGui
    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.Parent = char:FindFirstChild("Head") or char.PrimaryPart
    billboard.Adornee = char:FindFirstChild("Head") or char.PrimaryPart
    billboard.AlwaysOnTop = true

    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = targetPlayer.Name
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextSize = 16
    nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.Parent = billboard

    local healthLabel = Instance.new("TextLabel")
    -- FIXED #1: L·ªói C√∫ Ph√°p - ESP Health Label Typo
    healthLabel.Size = UDim2.new(1, 0, 0.5, 0) 
    healthLabel.Position = UDim2.new(0, 0, 0.5, 0)
    healthLabel.BackgroundTransparency = 1
    healthLabel.Text = "Health"
    healthLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
    healthLabel.TextSize = 14
    healthLabel.Font = Enum.Font.SourceSans
    healthLabel.Parent = billboard

    -- FIXED #2: L·ªói API - BoxHandleAdornment d√πng BrickColor
    local hitboxes = {}
    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") then
            local adornment = Instance.new("BoxHandleAdornment")
            adornment.Name = "ESPHitbox"
            adornment.Adornee = part
            adornment.AlwaysOnTop = true
            adornment.ZIndex = 1
            adornment.Transparency = 0.7
            adornment.Color = BrickColor.new("Bright red") -- Correct API
            adornment.Parent = part
            adornment.Size = part.Size
            table.insert(hitboxes, {Part = part, Adornment = adornment})
        end
    end

    ESPObjects[targetPlayer] = {
        Highlight = highlight, 
        Billboard = billboard, 
        NameLabel = nameLabel, 
        HealthLabel = healthLabel,
        Hitboxes = hitboxes
    }
end

local function updateHitboxScale(targetPlayer, scale)
    local data = ESPObjects[targetPlayer]
    if not data or not data.Hitboxes then return end
    
    for _, hbData in ipairs(data.Hitboxes) do
        if hbData.Part and hbData.Part.Parent and hbData.Adornment then
            hbData.Adornment.Size = hbData.Part.Size * scale
            hbData.Adornment.Visible = true
        end
    end
end

local function updateESP()
    if not ESPSettings.Enabled then
        for player, data in pairs(ESPObjects) do
            if data.Highlight then data.Highlight.Enabled = false end
            if data.Billboard then data.Billboard.Enabled = false end
            
            -- FIXED #10: Memory Leak - ESP Hitbox Destroy thay v√¨ ·∫©n
            if data.Hitboxes then
                for _, hb in ipairs(data.Hitboxes) do
                    if hb.Adornment and hb.Adornment.Parent then 
                        hb.Adornment:Destroy() 
                    end
                end
                data.Hitboxes = {} -- Clear table ƒë·ªÉ tr√°nh orphan references
            end
        end
        return
    end

    updatePlayerCache()

    for userId, cached in pairs(playerCache) do
        local targetPlayer = cached.Player
        local hasSelected = next(SelectedPlayerUserIds) ~= nil
        if hasSelected and not SelectedPlayerUserIds[targetPlayer.UserId] then continue end

        if targetPlayer ~= player and not shouldIgnoreTeam(targetPlayer, "esp") then
            createESP(targetPlayer)
            local data = ESPObjects[targetPlayer]
            local char = cached.Character
            local humanoid = cached.Humanoid

            if char and humanoid and data then
                -- Highlight
                if ESPSettings.ShowHighlight then
                    data.Highlight.Adornee = char
                    data.Highlight.Enabled = true
                else
                    data.Highlight.Enabled = false
                end

                -- Name/Health
                if ESPSettings.ShowName then
                    data.NameLabel.Text = targetPlayer.Name
                    data.NameLabel.Visible = true
                else
                    data.NameLabel.Visible = false
                end

                if ESPSettings.ShowHealth then
                    local health = humanoid.Health
                    local maxHealth = humanoid.MaxHealth
                    data.HealthLabel.Text = string.format("Health: %d/%d", math.floor(health), maxHealth)
                    data.HealthLabel.TextColor3 = health > maxHealth * 0.5 and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
                    data.HealthLabel.Visible = true
                else
                    data.HealthLabel.Visible = false
                end
                
                data.Billboard.Enabled = ESPSettings.ShowName or ESPSettings.ShowHealth

                -- Hitbox Visual Update
                if not data.Hitboxes or #data.Hitboxes == 0 then
                    -- Re-create hitboxes n·∫øu ƒë√£ b·ªã destroyed
                    local newHitboxes = {}
                    for _, part in ipairs(char:GetChildren()) do
                        if part:IsA("BasePart") then
                            local adornment = Instance.new("BoxHandleAdornment")
                            adornment.Adornee = part
                            adornment.AlwaysOnTop = true
                            adornment.ZIndex = 1
                            adornment.Transparency = 0.7
                            adornment.Color = BrickColor.new("Bright red")
                            adornment.Parent = part
                            table.insert(newHitboxes, {Part = part, Adornment = adornment})
                        end
                    end
                    data.Hitboxes = newHitboxes
                end
                updateHitboxScale(targetPlayer, ESPSettings.HitboxSize)
            end
        end
    end
end

RunService.Heartbeat:Connect(updateESP)

local function destroyESPObj(player)
    if ESPObjects[player] then
        if ESPObjects[player].Highlight then ESPObjects[player].Highlight:Destroy() end
        if ESPObjects[player].Billboard then ESPObjects[player].Billboard:Destroy() end
        if ESPObjects[player].Hitboxes then
            for _, hb in ipairs(ESPObjects[player].Hitboxes) do
                if hb.Adornment then hb.Adornment:Destroy() end
            end
        end
        ESPObjects[player] = nil
    end
end

local function toggleESP(state)
    ESPSettings.Enabled = state
    if not state then
        for p, _ in pairs(ESPObjects) do
            destroyESPObj(p)
        end
        ESPObjects = {}
    end
    Fluent:Notify({
        Title = "ESP",
        Content = state and "ƒê√£ B·∫¨T" or "ƒê√£ T·∫ÆT",
        Duration = 2
    })
end

-- FIXED #9: L·ªói Player Respawn - Update Selection Cache & Re-create ESP
Players.PlayerAdded:Connect(function(newPlayer)
    newPlayer.CharacterAdded:Connect(function(newChar)
        destroyESPObj(newPlayer)
        task.wait(1.5) -- ƒê·ª£i character load ƒë·ªß
        
        if ESPSettings.Enabled then
            createESP(newPlayer)
        end
        
        -- Re-validate selection logic
        if SelectedPlayerUserIds[newPlayer.UserId] then
             debugPrint("Re-validated selected player:", newPlayer.Name)
             -- Logic x·ª≠ l√Ω t√™n n·∫øu c·∫ßn thi·∫øt
        end
    end)
end)

-- FIXED #8 (FINAL CORRECTION): Player Leave Update Dropdown
Players.PlayerRemoving:Connect(function(p)
    destroyESPObj(p)
    
    local wasSelected = SelectedPlayerNames[p.Name] ~= nil
    SelectedPlayerNames[p.Name] = nil
    SelectedPlayerUserIds[p.UserId] = nil
    
    if wasSelected then
        local currentSelection = {}
        for name, _ in pairs(SelectedPlayerNames) do
            table.insert(currentSelection, name)
        end
        
        task.spawn(function()
            task.wait(0.1)
            PlayerDropdown:SetValue(currentSelection) -- C·∫≠p nh·∫≠t UI Dropdown
            updatePlayerListStatus()
        end)
        
        Fluent:Notify({
            Title = "M·ª•c ti√™u r·ªùi game",
            Content = p.Name .. " ƒë√£ tho√°t - ƒê√£ c·∫≠p nh·∫≠t",
            Duration = 2
        })
    end
end)

--==============================================================================
-- UI Creation
--==============================================================================

local Window = Fluent:CreateWindow({
    Title = "Aimbot Pro + Silent + ESP - Final Fixed",
    SubTitle = "Enhanced 2025",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 520),
    Acrylic = true,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ Title = "Aimbot", Icon = "crosshair" }),
    Advanced = Window:AddTab({ Title = "N√¢ng cao", Icon = "settings" }),
    Silent = Window:AddTab({ Title = "Silent Aim", Icon = "target" }),
    Players = Window:AddTab({ Title = "M·ª•c ti√™u", Icon = "users" }),
    Visual = Window:AddTab({ Title = "Hi·ªÉn th·ªã", Icon = "eye" }),
    ESP = Window:AddTab({ Title = "ESP", Icon = "map" })
}

-- Main Tab
local MainSection = Tabs.Main:AddSection("ƒêi·ªÅu khi·ªÉn ch√≠nh")

Tabs.Main:AddToggle("HardAimbotEnabled", {
    Title = "B·∫≠t Hard Aimbot",
    Default = false,
    Callback = function(value)
        toggleHardAimbot(value)
        Fluent:Notify({Title = "Hard Aimbot", Content = value and "ƒê√£ B·∫¨T" or "ƒê√£ T·∫ÆT", Duration = 2})
    end
})

Tabs.Main:AddToggle("SilentAimbotEnabled", {
    Title = "B·∫≠t Silent Aim",
    Default = false,
    Callback = function(value) toggleSilentAim(value) end
})

Tabs.Main:AddSlider("HardDistance", {
    Title = "Kho·∫£ng c√°ch (Hard)", Default = 50, Min = 10, Max = 1000, Rounding = 0,
    Callback = function(value) HardSettings.Distance = value end
})

Tabs.Main:AddSlider("HardSmoothness", {
    Title = "ƒê·ªô m∆∞·ª£t (Hard)", Default = 0.5, Min = 0.01, Max = 1, Rounding = 2,
    Callback = function(value) HardSettings.Smoothness = value end
})

Tabs.Main:AddDropdown("HardTargetPart", {
    Title = "Ph·∫ßn c∆° th·ªÉ ng·∫Øm (Hard)", Values = {"Head", "UpperTorso", "HumanoidRootPart"}, Default = "HumanoidRootPart",
    Callback = function(value) HardSettings.TargetPart = value end
})

-- Advanced Tab
local AdvancedSection = Tabs.Advanced:AddSection("T√πy ch·ªçn n√¢ng cao (Hard)")

Tabs.Advanced:AddToggle("CharacterTilt", {
    Title = "Ng·∫Øm theo chi·ªÅu d·ªçc", Default = false,
    Callback = function(value) HardSettings.CharacterTilt = value end
})

Tabs.Advanced:AddToggle("HardTeamCheck", {
    Title = "B·ªè qua ƒë·ªìng ƒë·ªôi (Hard)", Default = false,
    Callback = function(value) HardSettings.TeamCheck = value end
})

Tabs.Advanced:AddToggle("HardVisibilityCheck", {
    Title = "Ki·ªÉm tra t·∫ßm nh√¨n (Hard)", Default = false,
    Callback = function(value) HardSettings.VisibilityCheck = value end
})

Tabs.Advanced:AddToggle("HardPredictMovement", {
    Title = "D·ª± ƒëo√°n di chuy·ªÉn (Hard)", Default = false,
    Callback = function(value) HardSettings.PredictMovement = value end
})

Tabs.Advanced:AddSlider("HardPredictionStrength", {
    Title = "ƒê·ªô m·∫°nh d·ª± ƒëo√°n (Hard)", Default = 0.1, Min = 0, Max = 1, Rounding = 2,
    Callback = function(value) HardSettings.PredictionStrength = value end
})

-- Silent Tab
local SilentSection = Tabs.Silent:AddSection("C√†i ƒë·∫∑t Silent")

Tabs.Silent:AddSlider("SilentFOVSize", {
    Title = "K√≠ch th∆∞·ªõc FOV (Silent)", Default = 150, Min = 50, Max = 500, Rounding = 0,
    Callback = function(value) SilentSettings.FOVSize = value end
})

Tabs.Silent:AddToggle("SilentTeamCheck", {
    Title = "B·ªè qua ƒë·ªìng ƒë·ªôi (Silent)", Default = false,
    Callback = function(value) SilentSettings.TeamCheck = value end
})

Tabs.Silent:AddToggle("SilentVisibilityCheck", {
    Title = "Ki·ªÉm tra t·∫ßm nh√¨n (Silent)", Default = false,
    Callback = function(value) SilentSettings.VisibilityCheck = value end
})

Tabs.Silent:AddToggle("SilentPredictMovement", {
    Title = "D·ª± ƒëo√°n di chuy·ªÉn (Silent)", Default = false,
    Callback = function(value) SilentSettings.PredictMovement = value end
})

Tabs.Silent:AddSlider("SilentPredictionStrength", {
    Title = "ƒê·ªô m·∫°nh d·ª± ƒëo√°n (Silent)", Default = 0.1, Min = 0, Max = 1, Rounding = 2,
    Callback = function(value) SilentSettings.PredictionStrength = value end
})

Tabs.Silent:AddSlider("SilentHitChance", {
    Title = "T·ª∑ l·ªá hit (%)", Default = 100, Min = 0, Max = 100, Rounding = 0,
    Callback = function(value) SilentSettings.HitChance = value end
})

Tabs.Silent:AddDropdown("SilentTargetPart", {
    Title = "Ph·∫ßn c∆° th·ªÉ ng·∫Øm (Silent)", Values = {"Head", "HumanoidRootPart", "UpperTorso"}, Default = "Head",
    Callback = function(value) SilentSettings.TargetPart = value end
})

-- Players Tab
local PlayersSection = Tabs.Players:AddSection("Qu·∫£n l√Ω m·ª•c ti√™u")

local PlayerList = Tabs.Players:AddParagraph({
    Title = "Tr·∫°ng th√°i",
    Content = "ƒêang t·∫£i..."
})

-- FIXED #11: L·ªói API Compatibility - Fluent Paragraph Safe Call
local function updatePlayerListStatus()
    local playerCount = #Players:GetPlayers() - 1
    local selectedCount = 0
    for _ in pairs(SelectedPlayerUserIds) do selectedCount = selectedCount + 1 end

    local statusText = selectedCount == 0 and "üéØ Ch·∫ø ƒë·ªô: Ng·∫Øm T·∫§T C·∫¢" or 
                       string.format("üéØ Ch·∫ø ƒë·ªô: Ch·ªâ ng·∫Øm %d ng∆∞·ªùi ƒë√£ ch·ªçn", selectedCount)
    local newContent = string.format("üë• Ng∆∞·ªùi ch∆°i kh√°c: %d\n%s", playerCount, statusText)
    
    local success, err = pcall(function()
        if PlayerList.SetDesc then
            PlayerList:SetDesc(newContent)
        elseif PlayerList.SetContent then
            PlayerList:SetContent(newContent)
        elseif PlayerList.Set then
            PlayerList:Set({Content = newContent})
        end
    end)
    
    if not success then debugPrint("Paragraph update failed") end
end

-- FIXED #7: L·ªói Race Condition - Notification Spam
local PlayerDropdown = Tabs.Players:AddDropdown("PlayerSelector", {
    Title = "Ch·ªçn m·ª•c ti√™u c·ª• th·ªÉ",
    Description = "ƒê·ªÉ tr·ªëng = ng·∫Øm t·∫•t c·∫£",
    Values = {},
    Multi = true,
    Default = {},
    Callback = function(values)
        local newNames = {}
        local newUserIds = {}
        local validCount = 0
        local invalidPlayers = {}
        
        for _, playerName in ipairs(values) do
            local targetPlayer = Players:FindFirstChild(playerName)
            -- Validate player t·ªìn t·∫°i
            if targetPlayer then
                newNames[playerName] = true
                newUserIds[targetPlayer.UserId] = true
                validCount = validCount + 1
            else
                table.insert(invalidPlayers, playerName)
            end
        end
        
        SelectedPlayerNames = newNames
        SelectedPlayerUserIds = newUserIds
        
        updatePlayerListStatus()
        
        local targetInfo = validCount == 0 and "t·∫•t c·∫£" or validCount .. " ng∆∞·ªùi"
        local content = "ƒêang ng·∫Øm: " .. targetInfo
        
        if #invalidPlayers > 0 then
            content = content .. "\n‚ö†Ô∏è B·ªè qua: " .. table.concat(invalidPlayers, ", ")
        end
        
        Fluent:Notify({Title = "C·∫≠p nh·∫≠t m·ª•c ti√™u", Content = content, Duration = 2})
    end
})

-- FINAL FIX (refreshPlayerDropdown): ƒê·ªìng b·ªô UserIds sau khi refresh
local function refreshPlayerDropdown()
    local playerNames = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player then table.insert(playerNames, p.Name) end
    end
    table.sort(playerNames)
    
    local currentSelection = PlayerDropdown.Value
    local newSelection = {}
    local newNames = {}
    local newUserIds = {}
    
    for _, name in pairs(currentSelection) do
        if table.find(playerNames, name) then
            table.insert(newSelection, name)
            local targetPlayer = Players:FindFirstChild(name)
            if targetPlayer then
                newNames[name] = true
                newUserIds[targetPlayer.UserId] = true
            end
        end
    end
    
    SelectedPlayerNames = newNames
    SelectedPlayerUserIds = newUserIds
    
    PlayerDropdown:SetValues(playerNames)
    PlayerDropdown:SetValue(newSelection)
    updatePlayerListStatus()
end

Tabs.Players:AddButton({
    Title = "üîÑ L√†m m·ªõi danh s√°ch",
    Description = "C·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi ch∆°i m·ªõi",
    Callback = function()
        refreshPlayerDropdown()
        Fluent:Notify({ Title = "L√†m m·ªõi", Content = "ƒê√£ c·∫≠p nh·∫≠t danh s√°ch", Duration = 2 })
    end
})

Tabs.Players:AddButton({
    Title = "‚ùå B·ªè ch·ªçn t·∫•t c·∫£",
    Description = "X√≥a t·∫•t c·∫£ m·ª•c ti√™u ‚Üí Ng·∫Øm t·∫•t c·∫£ ng∆∞·ªùi ch∆°i",
    Callback = function()
        SelectedPlayerNames = {}
        SelectedPlayerUserIds = {}
        PlayerDropdown:SetValue({})
        updatePlayerListStatus()
        Fluent:Notify({ Title = "ƒê√£ x√≥a", Content = "Chuy·ªÉn sang ch·∫ø ƒë·ªô ng·∫Øm T·∫§T C·∫¢", Duration = 2 })
    end
})

-- Re-hook player removing to refresh dropdown
Players.PlayerRemoving:Connect(function(p)
    task.wait(0.1)
    refreshPlayerDropdown()
end)

Players.PlayerAdded:Connect(function(newPlayer)
    task.wait(1)
    refreshPlayerDropdown()
end)

-- Visual Tab
local VisualSection = Tabs.Visual:AddSection("FOV Circles")

Tabs.Visual:AddToggle("HardShowFOV", {
    Title = "Hi·ªÉn th·ªã FOV (Hard)", Default = false,
    Callback = function(value) HardSettings.ShowFOV = value end
})

Tabs.Visual:AddToggle("HardFOVCheck", {
    Title = "Ki·ªÉm tra FOV (Hard)", Default = false,
    Callback = function(value) HardSettings.FOVCheck = value end
})

Tabs.Visual:AddSlider("HardFOVSize", {
    Title = "K√≠ch th∆∞·ªõc FOV (Hard)", Default = 200, Min = 50, Max = 500, Rounding = 0,
    Callback = function(value) HardSettings.FOVSize = value end
})

Tabs.Visual:AddToggle("SilentShowFOV", {
    Title = "Hi·ªÉn th·ªã FOV (Silent)", Default = false,
    Callback = function(value) SilentSettings.ShowFOV = value end
})

-- ESP Tab
local ESPSection = Tabs.ESP:AddSection("ESP Settings")

Tabs.ESP:AddToggle("ESPToggle", {
    Title = "B·∫≠t ESP", Default = false,
    Callback = function(value) toggleESP(value) end
})

Tabs.ESP:AddToggle("ESPShowHighlight", {
    Title = "Hi·ªÉn th·ªã Highlight Tr·∫Øng", Default = true,
    Callback = function(value) ESPSettings.ShowHighlight = value end
})

Tabs.ESP:AddToggle("ESPShowName", {
    Title = "Hi·ªÉn th·ªã T√™n", Default = true,
    Callback = function(value) ESPSettings.ShowName = value end
})

Tabs.ESP:AddToggle("ESPShowHealth", {
    Title = "Hi·ªÉn th·ªã M√°u", Default = true,
    Callback = function(value) ESPSettings.ShowHealth = value end
})

Tabs.ESP:AddSlider("ESPHitboxSize", {
    Title = "K√≠ch th∆∞·ªõc Visual Hitbox", Default = 1.5, Min = 1, Max = 5, Rounding = 1,
    Callback = function(value) ESPSettings.HitboxSize = value end
})

Tabs.ESP:AddToggle("ESPTeamCheck", {
    Title = "B·ªè qua ƒë·ªìng ƒë·ªôi", Default = false,
    Callback = function(value) ESPSettings.TeamCheck = value end
})

--==============================================================================
-- Floating Toggle Button
--==============================================================================
local ToggleButton = Instance.new("ScreenGui")
ToggleButton.Name = "FixedToggle"
ToggleButton.ResetOnSpawn = false
ToggleButton.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ToggleButton.IgnoreGuiInset = true
ToggleButton.Parent = gethui and gethui() or CoreGui

local ToggleFrame = Instance.new("Frame")
ToggleFrame.Size = UDim2.new(0, 50, 0, 50)
ToggleFrame.Position = UDim2.new(0, 20, 0.5, -25)
ToggleFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
ToggleFrame.BorderSizePixel = 0
ToggleFrame.Active = true
ToggleFrame.Parent = ToggleButton

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = ToggleFrame

local UIStroke = Instance.new("UIStroke")
UIStroke.Color = Color3.fromRGB(80, 80, 80)
UIStroke.Thickness = 1.5
UIStroke.Parent = ToggleFrame

local ToggleBtn = Instance.new("TextButton")
ToggleBtn.Size = UDim2.new(1, 0, 1, 0)
ToggleBtn.BackgroundTransparency = 1
ToggleBtn.Text = "üéØ"
ToggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleBtn.TextSize = 24
ToggleBtn.Font = Enum.Font.GothamBold
ToggleBtn.Parent = ToggleFrame

local dragging, dragStart, startPos = false, nil, nil
ToggleFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = ToggleFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragging = false end
        end)
    end
end)

ToggleFrame.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        local newPos = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        local screenSize = Camera.ViewportSize
        newPos = UDim2.new(
            math.clamp(newPos.X.Scale, 0, 1), math.clamp(newPos.X.Offset, 0, screenSize.X - 50),
            math.clamp(newPos.Y.Scale, 0, 1), math.clamp(newPos.Y.Offset, 0, screenSize.Y - 50)
        )
        TweenService:Create(ToggleFrame, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {Position = newPos}):Play()
    end
end)

local guiMinimized = false
ToggleBtn.MouseButton1Click:Connect(function()
    guiMinimized = not guiMinimized
    Window:Minimize()
    local targetSize = guiMinimized and UDim2.new(0, 40, 0, 40) or UDim2.new(0, 50, 0, 50)
    local targetColor = guiMinimized and Color3.fromRGB(60, 60, 60) or Color3.fromRGB(30, 30, 30)
    local targetTextSize = guiMinimized and 20 or 24
    TweenService:Create(ToggleFrame, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {Size = targetSize, BackgroundColor3 = targetColor}):Play()
    TweenService:Create(UIStroke, TweenInfo.new(0.2), {Color = guiMinimized and Color3.fromRGB(150, 150, 150) or Color3.fromRGB(80, 80, 80)}):Play()
    TweenService:Create(ToggleBtn, TweenInfo.new(0.2), {TextSize = targetTextSize}):Play()
end)

RunService.Heartbeat:Connect(function()
    local isAnyOn = HardSettings.Enabled or SilentSettings.Enabled or ESPSettings.Enabled
    local targetColor = isAnyOn and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    UIStroke.Color = UIStroke.Color:Lerp(targetColor, 0.1)
end)

--==============================================================================
-- Initialization
--==============================================================================
updatePlayerParts()
refreshPlayerDropdown()

Fluent:Notify({Title = "Script Loaded", Content = "LethanhKhoi hub (Final Fixed Version)", Duration = 5})
