--==============================================================================
-- Services & Libraries
--==============================================================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local Teams = game:GetService("Teams")
local Camera = workspace.CurrentCamera
local Mouse = Players.LocalPlayer:GetMouse()
local GuiService = game:GetService("GuiService")

-- Load Fluent Library
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

--==============================================================================
-- Constants & Configuration
--==============================================================================
local CHARACTER_LOAD_WAIT = 0.5
local CACHE_UPDATE_INTERVAL = 1
local MAX_TARGET_PARTS = {"Head", "UpperTorso", "HumanoidRootPart"}

--==============================================================================
-- Variables
--==============================================================================
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local playerRoot, playerHumanoid

-- Hard Aimbot Settings
local HardSettings = {
    Enabled = false,
    Distance = 50,
    Smoothness = 0.5,
    CharacterTilt = false,
    TargetPart = "HumanoidRootPart",
    TeamCheck = false,
    FOVCheck = false,
    FOVSize = 200,
    ShowFOV = false,
    VisibilityCheck = false,
    PredictMovement = false,
    PredictionStrength = 0.1
}

-- Silent Aim Settings
local SilentSettings = {
    Enabled = false,
    FOVSize = 150,
    ShowFOV = false,
    TeamCheck = false,
    VisibilityCheck = false,
    PredictMovement = false,
    PredictionStrength = 0.1,
    HitChance = 100,
    TargetPart = "Head"
}

-- ESP Settings (Updated for Highlight + Name/Health + Hitbox)
local ESPSettings = {
    Enabled = false,
    ShowHighlight = true,
    ShowName = true,
    ShowHealth = true,
    HitboxSize = 1.5,  -- Scale factor for hitbox
    TeamCheck = false
}

-- Shared Player Selection (FIXED: Ensured proper filtering in all loops)
local SelectedPlayerNames = {}
local SelectedPlayerUserIds = {}
local hardAimbotConnection
local playerCache = {}
local lastCacheUpdate = 0

-- FOV Circles
local HardFOVCircle = Drawing.new("Circle")
HardFOVCircle.Thickness = 2
HardFOVCircle.NumSides = 64
HardFOVCircle.Radius = HardSettings.FOVSize
HardFOVCircle.Color = Color3.fromRGB(255, 255, 255)
HardFOVCircle.Visible = HardSettings.ShowFOV
HardFOVCircle.Filled = false
HardFOVCircle.Transparency = 0.8

local SilentFOVCircle = Drawing.new("Circle")
SilentFOVCircle.Thickness = 2
SilentFOVCircle.NumSides = 64
SilentFOVCircle.Radius = SilentSettings.FOVSize
SilentFOVCircle.Color = Color3.fromRGB(255, 0, 0)
SilentFOVCircle.Visible = SilentSettings.ShowFOV
SilentFOVCircle.Filled = false
SilentFOVCircle.Transparency = 0.8

-- ESP Objects (Updated: Highlight, BillboardGui for Name/Health)
local ESPObjects = {}  -- Player -> {Highlight, BillboardGui, OriginalSizes for hitbox}

-- Silent Aim Metatable Hook
local mt = getrawmetatable(game)
local oldIndex = mt.__index
setreadonly(mt, false)
local silentHook = newcclosure(function(self, key)
    if SilentSettings.Enabled and self == Mouse and key == "Hit" and math.random(1, 100) <= SilentSettings.HitChance then
        local target = getSilentTarget()
        if target then
            local predictedPos = predictSilentPosition(target)
            return CFrame.new(Mouse.Hit.Position, predictedPos)
        end
    end
    return oldIndex(self, key)
end)
mt.__index = silentHook
setreadonly(mt, true)

--==============================================================================
-- Utility Functions
--==============================================================================

local function updateHardFOVCircle()
    HardFOVCircle.Visible = HardSettings.ShowFOV
    HardFOVCircle.Radius = HardSettings.FOVSize
    HardFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
end

local function updateSilentFOVCircle()
    SilentFOVCircle.Visible = SilentSettings.ShowFOV
    SilentFOVCircle.Radius = SilentSettings.FOVSize
    SilentFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
end

local function isInFOV(position, fovSize, center)
    local screenPos, onScreen = Camera:WorldToViewportPoint(position)
    if not onScreen then return false end
    local distance = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
    return distance <= fovSize
end

local function isVisible(targetPart)
    local check = HardSettings.VisibilityCheck or SilentSettings.VisibilityCheck
    if not check then return true end
    if not playerRoot then return false end
    local ray = Ray.new(playerRoot.Position, (targetPart.Position - playerRoot.Position).Unit * 1000)
    local part = workspace:FindPartOnRayWithIgnoreList(ray, {character, targetPart.Parent})
    return part == nil or part:IsDescendantOf(targetPart.Parent)
end

local function shouldIgnoreTeam(targetPlayer, checkType)
    local teamCheck = checkType == "hard" and HardSettings.TeamCheck or 
                      checkType == "silent" and SilentSettings.TeamCheck or 
                      ESPSettings.TeamCheck
    if not teamCheck then return false end
    if not player.Team or not targetPlayer.Team then return false end
    return player.Team == targetPlayer.Team
end

local function predictSilentPosition(targetPart)
    if not SilentSettings.PredictMovement then return targetPart.Position end
    local root = targetPart.Parent:FindFirstChild("HumanoidRootPart")
    if root then
        local velocity = root.AssemblyVelocity
        local prediction = velocity * SilentSettings.PredictionStrength
        return targetPart.Position + prediction
    end
    return targetPart.Position
end

local function getSilentTarget()
    if not SilentSettings.Enabled then return nil end
    updatePlayerCache()
    local closestTarget, shortestDist = nil, math.huge
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    for userId, cachedPlayer in pairs(playerCache) do
        local targetPlayer = cachedPlayer.Player
        -- FIXED: Proper selection filter - if selected players exist, ONLY target selected ones
        local hasSelected = next(SelectedPlayerUserIds) ~= nil
        if hasSelected and not SelectedPlayerUserIds[targetPlayer.UserId] then continue end  -- Skip if not selected
        if targetPlayer ~= player and not shouldIgnoreTeam(targetPlayer, "silent") then

            local targetPart = cachedPlayer.Character:FindFirstChild(SilentSettings.TargetPart) or 
                               cachedPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetPart and isVisible(targetPart) then
                local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    if dist <= SilentSettings.FOVSize and dist < shortestDist then
                        shortestDist = dist
                        closestTarget = targetPart
                    end
                end
            end
        end
    end
    return closestTarget
end

--==============================================================================
-- Character Management
--==============================================================================

local function updatePlayerParts()
    if not character or not character.Parent then
        character = player.Character
        if not character then return false end
    end
    
    playerRoot = character:FindFirstChild("HumanoidRootPart")
    playerHumanoid = character:FindFirstChild("Humanoid")
    
    return playerRoot ~= nil and playerHumanoid ~= nil
end

local function onCharacterAdded(newChar)
    character = newChar
    task.wait(CHARACTER_LOAD_WAIT)
    updatePlayerParts()
end

player.CharacterAdded:Connect(onCharacterAdded)

--==============================================================================
-- Player Cache System
--==============================================================================

local function updatePlayerCache()
    local currentTime = tick()
    if currentTime - lastCacheUpdate < CACHE_UPDATE_INTERVAL then return end
    
    lastCacheUpdate = currentTime
    playerCache = {}
    
    for _, targetPlayer in ipairs(Players:GetPlayers()) do
        if targetPlayer ~= player and targetPlayer.Character then
            local targetChar = targetPlayer.Character
            local targetHumanoid = targetChar:FindFirstChildOfClass("Humanoid")
            local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
            
            if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
                playerCache[targetPlayer.UserId] = {
                    Player = targetPlayer,
                    Character = targetChar,
                    Root = targetRoot,
                    Humanoid = targetHumanoid
                }
            end
        end
    end
end

--==============================================================================
-- Target Selection (FIXED: Proper filtering for selected players in all targets)
--==============================================================================

local function isValidTarget(targetPlayer, checkType)
    if not targetPlayer or targetPlayer == player then return false end
    
    if shouldIgnoreTeam(targetPlayer, checkType) then return false end
    
    -- FIXED: If selected players exist, ONLY validate if UserId is in list; else all valid
    local hasSelectedPlayers = next(SelectedPlayerUserIds) ~= nil
    if hasSelectedPlayers then
        return SelectedPlayerUserIds[targetPlayer.UserId] == true
    end
    
    return true
end

local function getTargetPart(targetChar, partType)
    local partName = partType == "hard" and HardSettings.TargetPart or SilentSettings.TargetPart
    local part = targetChar:FindFirstChild(partName)
    if part then return part end
    
    for _, partName in ipairs(MAX_TARGET_PARTS) do
        part = targetChar:FindFirstChild(partName)
        if part then return part end
    end
    
    return nil
end

local function predictPosition(targetRoot, targetHumanoid, strength)
    local predict = HardSettings.PredictMovement
    if not predict then return targetRoot.Position end
    
    local velocity = targetRoot.AssemblyVelocity
    local prediction = velocity * strength
    
    return targetRoot.Position + prediction
end

local function getNearestTarget()
    if not HardSettings.Enabled or not updatePlayerParts() then return nil end
    if playerHumanoid.Health <= 0 then return nil end
    
    updatePlayerCache()
    
    local closestTarget, shortestDist = nil, math.huge
    local playerPosition = playerRoot.Position
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    for userId, cachedPlayer in pairs(playerCache) do
        -- FIXED: Apply isValidTarget filter BEFORE calculating distance
        if isValidTarget(cachedPlayer.Player, "hard") then
            local targetPart = getTargetPart(cachedPlayer.Character, "hard")
            
            if targetPart then
                local distance = (playerPosition - targetPart.Position).Magnitude
                
                if distance <= HardSettings.Distance and 
                   (not HardSettings.FOVCheck or isInFOV(targetPart.Position, HardSettings.FOVSize, center)) then
                    if isVisible(targetPart) and distance < shortestDist then
                        shortestDist = distance
                        closestTarget = {
                            Part = targetPart,
                            Root = cachedPlayer.Root,
                            Humanoid = cachedPlayer.Humanoid,
                            Distance = distance
                        }
                    end
                end
            end
        end
    end
    
    return closestTarget
end

--==============================================================================
-- Aiming Logic
--==============================================================================

local function aimAtTarget(targetData)
    if not updatePlayerParts() or playerHumanoid.Health <= 0 then return end
    
    local targetPos = predictPosition(targetData.Root, targetData.Humanoid, HardSettings.PredictionStrength)
    local aimPosition
    
    if HardSettings.CharacterTilt then
        if targetData.Part then targetPos = targetData.Part.Position end
        aimPosition = targetPos
    else
        aimPosition = Vector3.new(targetPos.X, playerRoot.Position.Y, targetPos.Z)
    end
    
    local goalCFrame = CFrame.new(playerRoot.Position, aimPosition)
    local smoothFactor = math.clamp(HardSettings.Smoothness, 0.01, 1)
    local smoothedCFrame = playerRoot.CFrame:Lerp(goalCFrame, smoothFactor)
    
    playerRoot.CFrame = smoothedCFrame
end

local function aimbotLoop()
    local target = getNearestTarget()
    if target then aimAtTarget(target) end
end

local function toggleHardAimbot(state)
    HardSettings.Enabled = state
    
    if hardAimbotConnection then
        hardAimbotConnection:Disconnect()
        hardAimbotConnection = nil
    end
    
    if state then
        hardAimbotConnection = RunService.Heartbeat:Connect(aimbotLoop)
    end
end

local function toggleSilentAim(state)
    SilentSettings.Enabled = state
    Fluent:Notify({
        Title = "Silent Aim",
        Content = state and "ƒê√£ B·∫¨T" or "ƒê√£ T·∫ÆT",
        Duration = 2
    })
end

--==============================================================================
-- FOV Updates
--==============================================================================
RunService.RenderStepped:Connect(function()
    updateHardFOVCircle()
    updateSilentFOVCircle()
end)

--==============================================================================
-- ESP Functions (FIXED: Full white Highlight, Name/Health Billboard, Hitbox scale)
--==============================================================================

local function createESP(targetPlayer)
    if ESPObjects[targetPlayer] then return end
    
    -- White Highlight for full body
    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromRGB(255, 255, 255)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Parent = targetPlayer.Character
    highlight.Adornee = targetPlayer.Character
    
    -- BillboardGui for Name and Health
    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.Parent = targetPlayer.Character:FindFirstChild("Head") or targetPlayer.Character.PrimaryPart
    billboard.Adornee = targetPlayer.Character:FindFirstChild("Head") or targetPlayer.Character.PrimaryPart
    billboard.AlwaysOnTop = true
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = targetPlayer.Name
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextSize = 16
    nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.Parent = billboard
    
    local healthLabel = Instance.new("TextLabel")
    healthLabel.Size = UDim2.new(1, 0, 0.5, 0)
    healthLabel.Position = UDim2.new(0, 0, 0.5, 0)
    healthLabel.BackgroundTransparency = 1
    healthLabel.Text = "Health: 100/100"
    healthLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
    healthLabel.TextSize = 14
    healthLabel.Font = Enum.Font.SourceSans
    healthLabel.Parent = billboard
    
    -- Store original sizes for hitbox
    local originalSizes = {}
    for _, part in ipairs(targetPlayer.Character:GetChildren()) do
        if part:IsA("BasePart") then
            originalSizes[part] = part.Size
        end
    end
    
    ESPObjects[targetPlayer] = {Highlight = highlight, Billboard = billboard, NameLabel = nameLabel, HealthLabel = healthLabel, OriginalSizes = originalSizes}
end

local function updateHitbox(targetPlayer, scale)
    local char = targetPlayer.Character
    if not char then return end
    local data = ESPObjects[targetPlayer]
    if not data then return end
    
    for part, origSize in pairs(data.OriginalSizes) do
        if part and part.Parent then
            part.Size = origSize * scale
        end
    end
end

local function updateESP()
    if not ESPSettings.Enabled then
        for player, data in pairs(ESPObjects) do
            if data.Highlight then data.Highlight.Enabled = false end
            if data.Billboard then data.Billboard.Enabled = false end
            -- Restore original hitbox
            if ESPSettings.HitboxSize > 1 then
                updateHitbox(player, 1)
            end
        end
        return
    end

    updatePlayerCache()

    for userId, cached in pairs(playerCache) do
        local targetPlayer = cached.Player
        -- FIXED: Apply selection filter to ESP too
        local hasSelected = next(SelectedPlayerUserIds) ~= nil
        if hasSelected and not SelectedPlayerUserIds[targetPlayer.UserId] then continue end
        
        if targetPlayer ~= player and not shouldIgnoreTeam(targetPlayer, "esp") then
            createESP(targetPlayer)
            local data = ESPObjects[targetPlayer]
            local char = cached.Character
            local humanoid = cached.Humanoid

            if char and humanoid then
                -- Highlight
                if ESPSettings.ShowHighlight then
                    data.Highlight.Adornee = char
                    data.Highlight.Enabled = true
                else
                    data.Highlight.Enabled = false
                end

                -- Name/Health Billboard
                if ESPSettings.ShowName then
                    data.NameLabel.Text = targetPlayer.Name
                    data.NameLabel.Visible = true
                else
                    data.NameLabel.Visible = false
                end

                if ESPSettings.ShowHealth then
                    local health = humanoid.Health
                    local maxHealth = humanoid.MaxHealth
                    data.HealthLabel.Text = string.format("Health: %d/%d", math.floor(health), maxHealth)
                    data.HealthLabel.TextColor3 = health > maxHealth * 0.5 and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
                    data.HealthLabel.Visible = true
                else
                    data.HealthLabel.Visible = false
                end

                data.Billboard.Enabled = ESPSettings.ShowName or ESPSettings.ShowHealth

                -- Hitbox
                updateHitbox(targetPlayer, ESPSettings.HitboxSize)
            end
        end
    end
end

RunService.Heartbeat:Connect(updateESP)  -- Use Heartbeat for health updates

local function toggleESP(state)
    ESPSettings.Enabled = state
    if not state then
        for player, data in pairs(ESPObjects) do
            if data.Highlight then data.Highlight:Destroy() end
            if data.Billboard then data.Billboard:Destroy() end
            -- Restore hitbox
            updateHitbox(player, 1)
        end
        ESPObjects = {}
    end
    Fluent:Notify({
        Title = "ESP",
        Content = state and "ƒê√£ B·∫¨T (Highlight + T√™n/M√°u + Hitbox)" or "ƒê√£ T·∫ÆT",
        Duration = 2
    })
end

Players.PlayerRemoving:Connect(function(p)
    if ESPObjects[p] then
        if ESPObjects[p].Highlight then ESPObjects[p].Highlight:Destroy() end
        if ESPObjects[p].Billboard then ESPObjects[p].Billboard:Destroy() end
        -- Restore hitbox if applied
        updateHitbox(p, 1)
        ESPObjects[p] = nil
    end
    SelectedPlayerNames[p.Name] = nil
    SelectedPlayerUserIds[p.UserId] = nil
end)

-- Handle character respawn for ESP
Players.PlayerAdded:Connect(function(newPlayer)
    newPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        if ESPSettings.Enabled then
            createESP(newPlayer)
        end
    end)
end)

--==============================================================================
-- UI Creation
--==============================================================================

local Window = Fluent:CreateWindow({
    Title = "Aimbot Pro + Silent + ESP - Fixed",
    SubTitle = "Enhanced 2025",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 520),
    Acrylic = true,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ Title = "Aimbot", Icon = "crosshair" }),
    Advanced = Window:AddTab({ Title = "N√¢ng cao", Icon = "settings" }),
    Silent = Window:AddTab({ Title = "Silent Aim", Icon = "target" }),
    Players = Window:AddTab({ Title = "M·ª•c ti√™u", Icon = "users" }),
    Visual = Window:AddTab({ Title = "Hi·ªÉn th·ªã", Icon = "eye" }),
    ESP = Window:AddTab({ Title = "ESP", Icon = "map" })
}

-- Main Tab
local MainSection = Tabs.Main:AddSection("ƒêi·ªÅu khi·ªÉn ch√≠nh")

Tabs.Main:AddToggle("HardAimbotEnabled", {
    Title = "B·∫≠t Hard Aimbot",
    Default = false,
    Callback = function(value)
        toggleHardAimbot(value)
        Fluent:Notify({
            Title = "Hard Aimbot",
            Content = value and "ƒê√£ B·∫¨T" or "ƒê√£ T·∫ÆT",
            Duration = 2
        })
    end
})

Tabs.Main:AddToggle("SilentAimbotEnabled", {
    Title = "B·∫≠t Silent Aim",
    Default = false,
    Callback = function(value)
        toggleSilentAim(value)
    end
})

Tabs.Main:AddSlider("HardDistance", {
    Title = "Kho·∫£ng c√°ch (Hard)",
    Default = 50,
    Min = 10,
    Max = 1000,
    Rounding = 0,
    Callback = function(value)
        HardSettings.Distance = value
    end
})

Tabs.Main:AddSlider("HardSmoothness", {
    Title = "ƒê·ªô m∆∞·ª£t (Hard)",
    Default = 0.5,
    Min = 0.01,
    Max = 1,
    Rounding = 2,
    Callback = function(value)
        HardSettings.Smoothness = value
    end
})

Tabs.Main:AddDropdown("HardTargetPart", {
    Title = "Ph·∫ßn c∆° th·ªÉ ng·∫Øm (Hard)",
    Values = {"Head", "UpperTorso", "HumanoidRootPart"},
    Default = "HumanoidRootPart",
    Callback = function(value)
        HardSettings.TargetPart = value
    end
})

-- Advanced Tab (for Hard)
local AdvancedSection = Tabs.Advanced:AddSection("T√πy ch·ªçn n√¢ng cao (Hard)")

Tabs.Advanced:AddToggle("CharacterTilt", {
    Title = "Ng·∫Øm theo chi·ªÅu d·ªçc",
    Default = false,
    Callback = function(value)
        HardSettings.CharacterTilt = value
    end
})

Tabs.Advanced:AddToggle("HardTeamCheck", {
    Title = "B·ªè qua ƒë·ªìng ƒë·ªôi (Hard)",
    Default = false,
    Callback = function(value)
        HardSettings.TeamCheck = value
    end
})

Tabs.Advanced:AddToggle("HardVisibilityCheck", {
    Title = "Ki·ªÉm tra t·∫ßm nh√¨n (Hard)",
    Description = "Ch·ªâ ng·∫Øm m·ª•c ti√™u nh√¨n th·∫•y ƒë∆∞·ª£c",
    Default = false,
    Callback = function(value)
        HardSettings.VisibilityCheck = value
    end
})

Tabs.Advanced:AddToggle("HardPredictMovement", {
    Title = "D·ª± ƒëo√°n di chuy·ªÉn (Hard)",
    Description = "Ng·∫Øm tr∆∞·ªõc v·ªã tr√≠ m·ª•c ti√™u s·∫Ω ƒë·∫øn",
    Default = false,
    Callback = function(value)
        HardSettings.PredictMovement = value
    end
})

Tabs.Advanced:AddSlider("HardPredictionStrength", {
    Title = "ƒê·ªô m·∫°nh d·ª± ƒëo√°n (Hard)",
    Default = 0.1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(value)
        HardSettings.PredictionStrength = value
    end
})

-- Silent Tab
local SilentSection = Tabs.Silent:AddSection("C√†i ƒë·∫∑t Silent")

Tabs.Silent:AddSlider("SilentFOVSize", {
    Title = "K√≠ch th∆∞·ªõc FOV (Silent)",
    Default = 150,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Callback = function(value)
        SilentSettings.FOVSize = value
    end
})

Tabs.Silent:AddToggle("SilentTeamCheck", {
    Title = "B·ªè qua ƒë·ªìng ƒë·ªôi (Silent)",
    Default = false,
    Callback = function(value)
        SilentSettings.TeamCheck = value
    end
})

Tabs.Silent:AddToggle("SilentVisibilityCheck", {
    Title = "Ki·ªÉm tra t·∫ßm nh√¨n (Silent)",
    Default = false,
    Callback = function(value)
        SilentSettings.VisibilityCheck = value
    end
})

Tabs.Silent:AddToggle("SilentPredictMovement", {
    Title = "D·ª± ƒëo√°n di chuy·ªÉn (Silent)",
    Default = false,
    Callback = function(value)
        SilentSettings.PredictMovement = value
    end
})

Tabs.Silent:AddSlider("SilentPredictionStrength", {
    Title = "ƒê·ªô m·∫°nh d·ª± ƒëo√°n (Silent)",
    Default = 0.1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(value)
        SilentSettings.PredictionStrength = value
    end
})

Tabs.Silent:AddSlider("SilentHitChance", {
    Title = "T·ª∑ l·ªá hit (%)",
    Default = 100,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Callback = function(value)
        SilentSettings.HitChance = value
    end
})

Tabs.Silent:AddDropdown("SilentTargetPart", {
    Title = "Ph·∫ßn c∆° th·ªÉ ng·∫Øm (Silent)",
    Values = {"Head", "HumanoidRootPart", "UpperTorso"},
    Default = "Head",
    Callback = function(value)
        SilentSettings.TargetPart = value
    end
})

-- Players Tab (FIXED: Ensured callback clears/rebuilds properly, forced status update)
local PlayersSection = Tabs.Players:AddSection("Qu·∫£n l√Ω m·ª•c ti√™u")

local PlayerList = Tabs.Players:AddParagraph({
    Title = "Tr·∫°ng th√°i",
    Content = "ƒêang t·∫£i..."
})

local function updatePlayerListStatus()
    local playerCount = #Players:GetPlayers() - 1
    local selectedCount = 0
    for _ in pairs(SelectedPlayerUserIds) do selectedCount = selectedCount + 1 end
    
    local statusText = selectedCount == 0 and "üéØ Ch·∫ø ƒë·ªô: Ng·∫Øm T·∫§T C·∫¢" or 
                       string.format("üéØ Ch·∫ø ƒë·ªô: Ch·ªâ ng·∫Øm %d ng∆∞·ªùi ƒë√£ ch·ªçn", selectedCount)
    
    local newContent = string.format("üë• Ng∆∞·ªùi ch∆°i kh√°c: %d\n%s", playerCount, statusText)
    PlayerList:SetContent(newContent)  -- FIXED: Use SetContent instead of SetDesc for Paragraph
    -- Force update with delay if needed
    task.wait(0.1)
    PlayerList:SetContent(newContent)
end

local PlayerDropdown = Tabs.Players:AddDropdown("PlayerSelector", {
    Title = "Ch·ªçn m·ª•c ti√™u c·ª• th·ªÉ",
    Description = "ƒê·ªÉ tr·ªëng = ng·∫Øm t·∫•t c·∫£",
    Values = {},
    Multi = true,
    Default = {},
    Callback = function(values)
        -- FIXED: Clear and rebuild - ensure UserId mapping is accurate
        SelectedPlayerNames = {}
        SelectedPlayerUserIds = {}
        
        for _, playerName in ipairs(values) do
            local targetPlayer = Players:FindFirstChild(playerName)
            if targetPlayer then
                SelectedPlayerNames[playerName] = true
                SelectedPlayerUserIds[targetPlayer.UserId] = true
                Fluent:Notify({
                    Title = "ƒê√£ ch·ªçn",
                    Content = "Th√™m " .. playerName .. " v√†o m·ª•c ti√™u",
                    Duration = 1
                })
            end
        end
        
        updatePlayerListStatus()  -- FIXED: Call immediately and with delay
        
        local selectedCount = #values
        local targetInfo = selectedCount == 0 and "t·∫•t c·∫£" or selectedCount .. " ng∆∞·ªùi"
        Fluent:Notify({
            Title = "C·∫≠p nh·∫≠t m·ª•c ti√™u",
            Content = "ƒêang ng·∫Øm: " .. targetInfo,
            Duration = 2
        })
    end
})

local function refreshPlayerDropdown()
    local playerNames = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player then table.insert(playerNames, p.Name) end
    end
    table.sort(playerNames)
    PlayerDropdown:SetValues(playerNames)
    updatePlayerListStatus()  -- FIXED: Always update after refresh
end

Tabs.Players:AddButton({
    Title = "üîÑ L√†m m·ªõi danh s√°ch",
    Description = "C·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi ch∆°i m·ªõi",
    Callback = function()
        refreshPlayerDropdown()
        Fluent:Notify({ Title = "L√†m m·ªõi", Content = "ƒê√£ c·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi ch∆°i", Duration = 2 })
    end
})

Tabs.Players:AddButton({
    Title = "‚ùå B·ªè ch·ªçn t·∫•t c·∫£",
    Description = "X√≥a t·∫•t c·∫£ m·ª•c ti√™u ‚Üí Ng·∫Øm t·∫•t c·∫£ ng∆∞·ªùi ch∆°i",
    Callback = function()
        SelectedPlayerNames = {}
        SelectedPlayerUserIds = {}
        PlayerDropdown:SetValue({})
        updatePlayerListStatus()  -- FIXED: Force update
        Fluent:Notify({ Title = "ƒê√£ x√≥a", Content = "Chuy·ªÉn sang ch·∫ø ƒë·ªô ng·∫Øm T·∫§T C·∫¢", Duration = 2 })
    end
})

Tabs.Players:AddParagraph({
    Title = "üìñ H∆∞·ªõng d·∫´n",
    Content = "‚Ä¢ Kh√¥ng ch·ªçn ai = Ng·∫Øm t·∫•t c·∫£\n‚Ä¢ Ch·ªçn ng∆∞·ªùi c·ª• th·ªÉ = Ch·ªâ ng·∫Øm ng∆∞·ªùi ƒë√≥\n‚Ä¢ C√≥ th·ªÉ ch·ªçn nhi·ªÅu ng∆∞·ªùi c√πng l√∫c"
})

Players.PlayerAdded:Connect(function(newPlayer)
    task.wait(1)
    refreshPlayerDropdown()
end)

-- Visual Tab
local VisualSection = Tabs.Visual:AddSection("FOV Circles")

Tabs.Visual:AddToggle("HardShowFOV", {
    Title = "Hi·ªÉn th·ªã FOV (Hard)",
    Default = false,
    Callback = function(value)
        HardSettings.ShowFOV = value
    end
})

Tabs.Visual:AddToggle("HardFOVCheck", {
    Title = "Ki·ªÉm tra FOV (Hard)",
    Default = false,
    Callback = function(value)
        HardSettings.FOVCheck = value
    end
})

Tabs.Visual:AddSlider("HardFOVSize", {
    Title = "K√≠ch th∆∞·ªõc FOV (Hard)",
    Default = 200,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Callback = function(value)
        HardSettings.FOVSize = value
    end
})

Tabs.Visual:AddToggle("SilentShowFOV", {
    Title = "Hi·ªÉn th·ªã FOV (Silent)",
    Default = false,
    Callback = function(value)
        SilentSettings.ShowFOV = value
    end
})

-- ESP Tab (Updated for new features)
local ESPSection = Tabs.ESP:AddSection("ESP Settings")

Tabs.ESP:AddToggle("ESPToggle", {
    Title = "B·∫≠t ESP",
    Default = false,
    Callback = function(value)
        toggleESP(value)
    end
})

Tabs.ESP:AddToggle("ESPShowHighlight", {
    Title = "Hi·ªÉn th·ªã Highlight Tr·∫Øng",
    Default = true,
    Callback = function(value)
        ESPSettings.ShowHighlight = value
    end
})

Tabs.ESP:AddToggle("ESPShowName", {
    Title = "Hi·ªÉn th·ªã T√™n",
    Default = true,
    Callback = function(value)
        ESPSettings.ShowName = value
    end
})

Tabs.ESP:AddToggle("ESPShowHealth", {
    Title = "Hi·ªÉn th·ªã M√°u",
    Default = true,
    Callback = function(value)
        ESPSettings.ShowHealth = value
    end
})

Tabs.ESP:AddSlider("ESPHitboxSize", {
    Title = "K√≠ch th∆∞·ªõc Hitbox",
    Default = 1.5,
    Min = 1,
    Max = 3,
    Rounding = 1,
    Callback = function(value)
        ESPSettings.HitboxSize = value
    end
})

Tabs.ESP:AddToggle("ESPTeamCheck", {
    Title = "B·ªè qua ƒë·ªìng ƒë·ªôi",
    Default = false,
    Callback = function(value)
        ESPSettings.TeamCheck = value
    end
})

--==============================================================================
-- Fixed Floating Toggle Button (Added scale shrink animation)
--==============================================================================

local ToggleButton = Instance.new("ScreenGui")
ToggleButton.Name = "FixedToggle"
ToggleButton.ResetOnSpawn = false
ToggleButton.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ToggleButton.IgnoreGuiInset = true
ToggleButton.Parent = gethui and gethui() or CoreGui

local ToggleFrame = Instance.new("Frame")
ToggleFrame.Size = UDim2.new(0, 50, 0, 50)
ToggleFrame.Position = UDim2.new(0, 20, 0.5, -25)
ToggleFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
ToggleFrame.BorderSizePixel = 0
ToggleFrame.Active = true
ToggleFrame.Parent = ToggleButton

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = ToggleFrame

local UIStroke = Instance.new("UIStroke")
UIStroke.Color = Color3.fromRGB(80, 80, 80)
UIStroke.Thickness = 1.5
UIStroke.Parent = ToggleFrame

local ToggleBtn = Instance.new("TextButton")
ToggleBtn.Size = UDim2.new(1, 0, 1, 0)
ToggleBtn.BackgroundTransparency = 1
ToggleBtn.Text = "üéØ"
ToggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleBtn.TextSize = 24
ToggleBtn.Font = Enum.Font.GothamBold
ToggleBtn.Parent = ToggleFrame

-- FIXED Dragging (smooth, bounded)
local dragging = false
local dragStart, startPos

ToggleFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = ToggleFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

ToggleFrame.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        local newPos = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        
        -- Bound to screen
        local screenSize = Camera.ViewportSize
        newPos = UDim2.new(
            math.clamp(newPos.X.Scale, 0, 1),
            math.clamp(newPos.X.Offset, 0, screenSize.X - 50),
            math.clamp(newPos.Y.Scale, 0, 1),
            math.clamp(newPos.Y.Offset, 0, screenSize.Y - 50)
        )
        
        TweenService:Create(ToggleFrame, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {Position = newPos}):Play()
    end
end)

-- FIXED GUI Toggle (uses Fluent's Minimize properly - toggles without losing button)
-- ADDED: Scale animation - shrinks to 40x40 when minimized
local guiMinimized = false
ToggleBtn.MouseButton1Click:Connect(function()
    guiMinimized = not guiMinimized
    Window:Minimize()  -- Fluent's Minimize toggles state reliably
    
    -- Visual feedback with scale
    local targetSize = guiMinimized and UDim2.new(0, 40, 0, 40) or UDim2.new(0, 50, 0, 50)
    local targetColor = guiMinimized and Color3.fromRGB(60, 60, 60) or Color3.fromRGB(30, 30, 30)
    local targetIcon = guiMinimized and "üëë" or "üëë"
    local targetTextSize = guiMinimized and 20 or 24
    
    TweenService:Create(ToggleFrame, TweenInfo.new(0.2, Enum.EasingStyle.Quad), { 
        Size = targetSize,
        BackgroundColor3 = targetColor 
    }):Play()
    TweenService:Create(UIStroke, TweenInfo.new(0.2), { 
        Color = guiMinimized and Color3.fromRGB(150, 150, 150) or Color3.fromRGB(80, 80, 80),
        Thickness = guiMinimized and 1.2 or 1.5 
    }):Play()
    TweenService:Create(ToggleBtn, TweenInfo.new(0.2), { TextSize = targetTextSize }):Play()
    ToggleBtn.Text = targetIcon
end)

-- Dynamic stroke color for aim states
RunService.Heartbeat:Connect(function()
    local isAnyOn = HardSettings.Enabled or SilentSettings.Enabled or ESPSettings.Enabled
    local targetColor = isAnyOn and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    UIStroke.Color = UIStroke.Color:Lerp(targetColor, 0.1)
end)

--==============================================================================
-- Initialization
--==============================================================================

updatePlayerParts()
refreshPlayerDropdown()

Fluent:Notify({
    Title = "Script Loaded",
    Content = "LethanhKhoi hub",
    Duration = 5
})